/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ocanvas/index.js":
/*!***************************************!*\
  !*** ./node_modules/ocanvas/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * oCanvas v2.10.0\n * http://ocanvas.org/\n *\n * Copyright 2011-2018, Johannes Koggdal\n * Licensed under the MIT license\n * http://ocanvas.org/license\n *\n * Including Xccessors by Eli Grey\n * Including easing equations by Robert Penner\n */\n\n__webpack_require__(/*! ./src/core */ \"./node_modules/ocanvas/src/core.js\");\n__webpack_require__(/*! ./src/utils */ \"./node_modules/ocanvas/src/utils.js\");\n__webpack_require__(/*! ./src/timeline */ \"./node_modules/ocanvas/src/timeline.js\");\n__webpack_require__(/*! ./src/keyboard */ \"./node_modules/ocanvas/src/keyboard.js\");\n__webpack_require__(/*! ./src/mouse */ \"./node_modules/ocanvas/src/mouse.js\");\n__webpack_require__(/*! ./src/touch */ \"./node_modules/ocanvas/src/touch.js\");\n__webpack_require__(/*! ./src/tools */ \"./node_modules/ocanvas/src/tools.js\");\n__webpack_require__(/*! ./src/events */ \"./node_modules/ocanvas/src/events.js\");\n__webpack_require__(/*! ./src/draw */ \"./node_modules/ocanvas/src/draw.js\");\n__webpack_require__(/*! ./src/background */ \"./node_modules/ocanvas/src/background.js\");\n__webpack_require__(/*! ./src/scenes */ \"./node_modules/ocanvas/src/scenes.js\");\n__webpack_require__(/*! ./src/style */ \"./node_modules/ocanvas/src/style.js\");\n__webpack_require__(/*! ./src/animation */ \"./node_modules/ocanvas/src/animation.js\");\n__webpack_require__(/*! ./src/displayobject */ \"./node_modules/ocanvas/src/displayobject.js\");\n__webpack_require__(/*! ./src/displayobjects/rectangle */ \"./node_modules/ocanvas/src/displayobjects/rectangle.js\");\n__webpack_require__(/*! ./src/displayobjects/image */ \"./node_modules/ocanvas/src/displayobjects/image.js\");\n__webpack_require__(/*! ./src/displayobjects/text */ \"./node_modules/ocanvas/src/displayobjects/text.js\");\n__webpack_require__(/*! ./src/displayobjects/arc */ \"./node_modules/ocanvas/src/displayobjects/arc.js\");\n__webpack_require__(/*! ./src/displayobjects/ellipse */ \"./node_modules/ocanvas/src/displayobjects/ellipse.js\");\n__webpack_require__(/*! ./src/displayobjects/polygon */ \"./node_modules/ocanvas/src/displayobjects/polygon.js\");\n__webpack_require__(/*! ./src/displayobjects/line */ \"./node_modules/ocanvas/src/displayobjects/line.js\");\n__webpack_require__(/*! ./src/displayobjects/sprite */ \"./node_modules/ocanvas/src/displayobjects/sprite.js\");\n__webpack_require__(/*! ./src/xccessors */ \"./node_modules/ocanvas/src/xccessors.js\");\n\nmodule.exports = __webpack_require__.g.oCanvas;\ndelete __webpack_require__.g.oCanvas;\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/index.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/animation.js":
/*!***********************************************!*\
  !*** ./node_modules/ocanvas/src/animation.js ***!
  \***********************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\twindow.logs = [];\n\n\t// Define the class\n\tvar animation = function () {\n\n\t\t// Return an object when instantiated\n\t\tvar module = {\n\n\t\t\tdurations: {\n\t\t\t\t\"short\": 500,\n\t\t\t\t\"normal\": 1000,\n\t\t\t\t\"long\": 2000\n\t\t\t},\n\n\t\t\tdefaults: {\n\t\t\t\tduration: \"normal\",\n\t\t\t\teasing: \"ease-in-out\" // Deprecated value, will be replaced by \"ease-in-out-cubic\"\n\t\t\t},\n\n\t\t\tanimate: function (obj, args) {\n\t\t\t\tvar argData = this.parseArguments(args);\n\t\t\t\tvar props = argData.properties;\n\t\t\t\tvar options = argData.options;\n\n\t\t\t\t// Create queue and get it\n\t\t\t\tvar queue = this.queues.create(obj, options.queue);\n\n\t\t\t\t// Create the animation object\n\t\t\t\tvar animation = {\n\t\t\t\t\tobj: obj,\n\t\t\t\t\tproperties: props,\n\t\t\t\t\tstartValues: {},\n\t\t\t\t\tdiffValues: {},\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tqueue: queue,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: options.easing,\n\t\t\t\t\t\tcallback: options.callback\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Add the animation to the queue and run queue\n\t\t\t\tqueue.add(animation);\n\t\t\t\tqueue.run();\n\t\t\t},\n\n\t\t\tparseArguments: function (args) {\n\t\t\t\targs = Array.prototype.slice.call(args);\n\t\t\t\targs[1] = args[1] || {};\n\t\t\t\tvar options, props;\n\n\t\t\t\t// Check for new syntax\n\t\t\t\tif (typeof args[1] === \"object\") {\n\t\t\t\t\tprops = args[0];\n\n\t\t\t\t\t// Use passed in options, with fallbacks\n\t\t\t\t\toptions = oCanvas.extend({\n\t\t\t\t\t\tduration: this.defaults.duration,\n\t\t\t\t\t\teasing: this.defaults.easing,\n\t\t\t\t\t\tqueue: \"default\",\n\t\t\t\t\t\tcallback: function () {}\n\t\t\t\t\t}, args[1]);\n\n\t\t\t\t\toptions.easing = this.parseEasingOption(options.easing);\n\t\t\t\t\toptions.duration = this.parseDurationOption(options.duration);\n\n\t\t\t\t// Or parse old deprecated syntax\n\t\t\t\t} else {\n\t\t\t\t\tprops = args.shift();\n\t\t\t\t\toptions = this.getAnimateArguments(args);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tproperties: props,\n\t\t\t\t\toptions: options\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tparseEasingOption: function (easing) {\n\t\t\t\tif (typeof easing === \"string\") {\n\t\t\t\t\t// The cubic-bezier() syntax is now deprecated (though it was never really public)\n\t\t\t\t\tif (~easing.indexOf(\"cubic-bezier\")) {\n\t\t\t\t\t\treturn this.getCustomCubicBezier(easing) || this.easing[this.defaults.easing];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.easing[easing] || this.easing[this.defaults.easing];\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof easing == \"function\") {\n\t\t\t\t\treturn easing;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.easing[this.defaults.easing];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tparseDurationOption: function (duration) {\n\t\t\t\tvar durations = module.durations;\n\t\t\t\tif (typeof duration === \"string\") {\n\t\t\t\t\treturn durations[duration] || durations[module.defaults.duration];\n\t\t\t\t}\n\t\t\t\treturn duration;\n\t\t\t},\n\n\t\t\trunAnimation: function (animation, callback) {\n\t\t\t\tvar obj, props, options, prop;\n\n\t\t\t\tobj = animation.obj;\n\t\t\t\toptions = animation.options;\n\t\t\t\tanimation.advanceCallback = callback;\n\n\t\t\t\t// Indicate to the module that we want to run an animation, which will start a redraw loop\n\t\t\t\tthis.mainTimer.add(animation);\n\n\t\t\t\t// Collect values for the animation\n\t\t\t\tvar props = this.parseProperties(animation.properties, obj);\n\t\t\t\tanimation.properties = props.properties;\n\t\t\t\tanimation.startValues = props.startValues;\n\t\t\t\tanimation.diffValues = props.diffValues;\n\n\t\t\t\t// Set initial time\n\t\t\t\tanimation.startTime = new Date().getTime();\n\t\t\t},\n\n\t\t\tparseProperties: function (props, obj) {\n\t\t\t\tvar startValues = {};\n\t\t\t\tvar diffValues = {};\n\t\t\t\tfor (var prop in props) {\n\t\t\t\t\tif (oCanvas.isNumber(props[prop])) {\n\t\t\t\t\t\tstartValues[prop] = obj[prop] || 0;\n\t\t\t\t\t\tdiffValues[prop] = props[prop] - (obj[prop] || 0);\n\t\t\t\t\t} else if (typeof props[prop] === \"object\") {\n\t\t\t\t\t\tvar parsedProps = this.parseProperties(props[prop], obj[prop]);\n\t\t\t\t\t\tstartValues[prop] = parsedProps.startValues;\n\t\t\t\t\t\tdiffValues[prop] = parsedProps.diffValues;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete props[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tproperties: props,\n\t\t\t\t\tstartValues: startValues,\n\t\t\t\t\tdiffValues: diffValues\n\t\t\t\t};\n\t\t\t},\n\n\t\t\ttick: function (animation) {\n\t\t\t\tvar timeDiff, position, propertyPosition, startValues, diffValues, prop;\n\n\t\t\t\t// Calculate position in time for the animation\n\t\t\t\ttimeDiff = new Date().getTime() - animation.startTime;\n\t\t\t\tposition = timeDiff / animation.options.duration;\n\n\t\t\t\t// Stop the animation if the duration has passed\n\t\t\t\tif (position > 1) {\n\t\t\t\t\tthis.setEndValues(animation);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Calculate the property position based on the easing function\n\t\t\t\tif (animation.options.easing.length === 1) {\n\t\t\t\t\t// Deprecated syntax\n\t\t\t\t\tpropertyPosition = animation.options.easing.call(this.easing, position);\n\t\t\t\t} else {\n\t\t\t\t\t// New syntax\n\t\t\t\t\tpropertyPosition = animation.options.easing.call(this.easing, timeDiff, 0, 1, animation.options.duration);\n\t\t\t\t}\n\n\t\t\t\t// Set new values for all properties\n\t\t\t\tstartValues = animation.startValues;\n\t\t\t\tdiffValues = animation.diffValues;\n\t\t\t\tfor (prop in diffValues) {\n\t\t\t\t\tthis.setObjectProperty(animation.obj, prop, startValues[prop], diffValues[prop], propertyPosition);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tsetObjectProperty: function (obj, property, startValue, diffValue, propertyPosition) {\n\t\t\t\tif (oCanvas.isNumber(startValue)) {\n\t\t\t\t\tobj[property] = startValue + diffValue * propertyPosition;\n\t\t\t\t} else {\n\t\t\t\t\tfor (var prop in startValue) {\n\t\t\t\t\t\tthis.setObjectProperty(obj[property], prop, startValue[prop], diffValue[prop], propertyPosition);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsetEndValues: function (animation) {\n\t\t\t\tvar obj = animation.obj;\n\t\t\t\tvar startValues = animation.startValues;\n\t\t\t\tvar diffValues = animation.diffValues;\n\t\t\t\tfor (var prop in animation.properties) {\n\t\t\t\t\tthis.setObjectProperty(obj, prop, startValues[prop], diffValues[prop], 1);\n\t\t\t\t}\n\t\t\t\tif (!this.core.timeline.running) {\n\t\t\t\t\tthis.core.draw.redraw(true);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Method that collects arguments passed in to the animate method, and corrects with defaults.\n\t\t\t// Used to parse the deprecated syntax of the animate method.\n\t\t\tgetAnimateArguments: function (args) {\n\t\t\t\tvar duration, easing, newQueue, callback;\n\n\t\t\t\t// First argument is already pulled out (properties object)\n\n\t\t\t\t// Second argument\n\t\t\t\tif (typeof args[0] === \"number\") {\n\t\t\t\t\tduration = args[0];\n\t\t\t\t} else if (typeof args[0] === \"string\") {\n\t\t\t\t\tif (args[0] in this.durations) {\n\t\t\t\t\t\tduration = this.durations[args[0]];\n\t\t\t\t\t} else if (args[0] in this.easing) {\n\t\t\t\t\t\teasing = this.easing[args[0]];\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof args[0] === \"boolean\") {\n\t\t\t\t\tnewQueue = args[0];\n\t\t\t\t} else if (typeof args[0] === \"function\") {\n\t\t\t\t\tif (typeof args[1] === \"function\") {\n\t\t\t\t\t\teasing = args[0];\n\t\t\t\t\t\tcallback = args[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Third argument\n\t\t\t\tif (typeof args[1] === \"string\") {\n\t\t\t\t\teasing = this.easing[args[1]];\n\t\t\t\t} else if (typeof args[1] === \"function\") {\n\t\t\t\t\tif (args[2] !== undefined) {\n\t\t\t\t\t\teasing = args[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback = args[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fourth argument\n\t\t\t\tif (args[2] !== undefined) {\n\t\t\t\t\tif (typeof args[2] === \"function\") {\n\t\t\t\t\t\tcallback = args[2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewQueue = !!args[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fifth argument\n\t\t\t\tif (args[3] !== undefined) {\n\t\t\t\t\tcallback = args[3];\n\t\t\t\t}\n\n\t\t\t\tif (!easing) {\n\t\t\t\t\teasing = typeof args[0] === \"string\" ? args[0] : \"\";\n\t\t\t\t\teasing = ~easing.indexOf(\"cubic-bezier\") ? easing : undefined;\n\t\t\t\t\tif (!easing) {\n\t\t\t\t\t\teasing = typeof args[1] === \"string\" ? args[1] : \"\";\n\t\t\t\t\t\teasing = ~easing.indexOf(\"cubic-bezier\") ? easing : undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (easing) {\n\t\t\t\t\t\teasing = this.getCustomCubicBezier(easing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tduration = duration || this.durations[this.defaults.duration];\n\t\t\t\teasing = easing || this.easing[this.defaults.easing];\n\t\t\t\tnewQueue = newQueue !== undefined ? newQueue : false;\n\t\t\t\tcallback = callback || function () {};\n\n\t\t\t\treturn {\n\t\t\t\t\tduration: duration,\n\t\t\t\t\teasing: easing,\n\t\t\t\t\tqueue: newQueue ? undefined : \"default\",\n\t\t\t\t\tcallback: callback\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tgetCustomCubicBezier: function (value) {\n\t\t\t\tvar match, x1, y1, x2, y2;\n\n\t\t\t\t// Get the values from the form:\n\t\t\t\t//   cubic-bezier(x1, y1, x2, y2)\n\t\t\t\tmatch = value.match(/cubic-bezier\\(\\s*(.*?),\\s*(.*?),\\s*(.*?),\\s*(.*?)\\)/);\n\n\t\t\t\t// Abort early if the input string is not valid\n\t\t\t\tif (!match) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Parse numbers\n\t\t\t\tx1 = !isNaN(parseFloat(match[1])) ? parseFloat(match[1]) : 0,\n\t\t\t\ty1 = !isNaN(parseFloat(match[2])) ? parseFloat(match[2]) : 0,\n\t\t\t\tx2 = !isNaN(parseFloat(match[3])) ? parseFloat(match[3]) : 1,\n\t\t\t\ty2 = !isNaN(parseFloat(match[4])) ? parseFloat(match[4]) : 1;\n\n\t\t\t\treturn function (time) {\n\t\t\t\t\treturn this.cubicBezier(x1, y1, x2, y2, time);\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tstop: function (obj) {\n\t\t\t\tfor (var name in obj.animationQueues) {\n\t\t\t\t\tobj.animationQueues[name].clear(false);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfinish: function (obj) {\n\t\t\t\tfor (var name in obj.animationQueues) {\n\t\t\t\t\tobj.animationQueues[name].clear(true);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdelay: function (obj, duration, options) {\n\t\t\t\tvar queue = obj.animationQueues[(options && options.queue) || \"default\"];\n\t\t\t\tif (queue) {\n\t\t\t\t\tqueue.add({ type: \"delay\", duration: duration || 0 });\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tmainTimer: {\n\t\t\t\tanimations: [],\n\t\t\t\tadd: function (animation) {\n\t\t\t\t\tthis.animations.push(animation);\n\t\t\t\t\tif (this.animations.length === 1) {\n\t\t\t\t\t\tthis.start();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tremove: function (animation) {\n\t\t\t\t\tthis.animations.splice(this.animations.indexOf(animation), 1);\n\t\t\t\t\tif (this.animations.length === 0) {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tstart: function () {\n\t\t\t\t\tthis.tick();\n\t\t\t\t},\n\t\t\t\tstop: function () {\n\t\t\t\t\tcancelAnimationFrame(this.timer);\n\t\t\t\t},\n\t\t\t\ttick: function () {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tself.timer = requestAnimationFrame(function () { self.tick(); });\n\n\t\t\t\t\t\tvar animations = self.animations;\n\t\t\t\t\t\tvar animation;\n\t\t\t\t\t\tfor (var i = 0, l = animations.length; i < l; i++) {\n\t\t\t\t\t\t\tanimation = animations[i];\n\t\t\t\t\t\t\tif (!animation.cancelled) {\n\t\t\t\t\t\t\t\tif (!module.tick(animation)) {\n\t\t\t\t\t\t\t\t\tmodule.mainTimer.remove(animation);\n\t\t\t\t\t\t\t\t\ti--; l--;\n\t\t\t\t\t\t\t\t\tanimation.advanceCallback();\n\t\t\t\t\t\t\t\t\tanimation.options.callback.call(animation.obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!module.core.timeline.running) {\n\t\t\t\t\t\t\tmodule.core.draw.redraw(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 1000 / module.core.settings.fps);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tqueues: {\n\n\t\t\t\tcreate: function (obj, name) {\n\t\t\t\t\tif (name === undefined) {\n\t\t\t\t\t\tname = Math.round(new Date().getTime() * Math.random()).toString();\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj.animationQueues[name]) {\n\t\t\t\t\t\tobj.animationQueues[name] = {\n\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\tlist: [],\n\t\t\t\t\t\t\tisRunning: false,\n\t\t\t\t\t\t\tadd: function (animation) {\n\t\t\t\t\t\t\t\tthis.list.push(animation);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tremove: function (animation) {\n\t\t\t\t\t\t\t\tif (animation) {\n\t\t\t\t\t\t\t\t\tvar index = this.list.indexOf(animation);\n\t\t\t\t\t\t\t\t\tif (~index) {\n\t\t\t\t\t\t\t\t\t\tthis.list.splice(index, 1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.list.shift();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trun: function () {\n\t\t\t\t\t\t\t\tif (!this.isRunning && this.list.length > 0) {\n\t\t\t\t\t\t\t\t\tthis.isRunning = true;\n\t\t\t\t\t\t\t\t\tvar listItem = this.list[0];\n\t\t\t\t\t\t\t\t\tvar queue = this;\n\t\t\t\t\t\t\t\t\tif (listItem.type === \"delay\") {\n\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\tqueue.advance();\n\t\t\t\t\t\t\t\t\t\t}, listItem.duration);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tmodule.runAnimation(listItem, function () { queue.advance(); });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadvance: function () {\n\t\t\t\t\t\t\t\tthis.list.shift();\n\t\t\t\t\t\t\t\tthis.isRunning = false;\n\t\t\t\t\t\t\t\tthis.run();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclear: function (finish) {\n\t\t\t\t\t\t\t\tif (this.isRunning) {\n\t\t\t\t\t\t\t\t\tvar animation = this.list[0];\n\t\t\t\t\t\t\t\t\tanimation.cancelled = true;\n\n\t\t\t\t\t\t\t\t\tif (finish) {\n\t\t\t\t\t\t\t\t\t\tmodule.setEndValues(animation);\n\t\t\t\t\t\t\t\t\t\tanimation.options.callback.call(animation.obj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis.isRunning = false;\n\t\t\t\t\t\t\t\t\tmodule.mainTimer.remove(animation);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.list.length = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn this.get(obj, name);\n\t\t\t\t},\n\n\t\t\t\tget: function (obj, name) {\n\t\t\t\t\treturn obj.animationQueues[name];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Easing functions take at least four arguments:\n\t\t\t// t: Current time\n\t\t\t// b: Start value\n\t\t\t// c: Change in value from start to end\n\t\t\t// d: Total duration of the animation\n\t\t\t// Some easing functions also take some optional arguments:\n\t\t\t// a: Amplitude\n\t\t\t// p: Period\n\t\t\t// s: Overshoot amount\n\t\t\t//\n\t\t\t// They return the new value. In oCanvas, 0 is passed in\n\t\t\t// as start value and 1 as change in value. This will\n\t\t\t// generate a factor that can be used on multiple property\n\t\t\t// values, and the easing function will only need to be\n\t\t\t// called once per frame, instead of once per property per frame.\n\t\t\t// The additional arguments are not passed though, which will\n\t\t\t// make them take the default values in those functions.\n\t\t\t//\n\t\t\t// The equations are created by Robert Penner.\n\t\t\t// (c) 2003 Robert Penner, all rights reserved.\n\t\t\t// The work is subject to the terms in http://www.robertpenner.com/easing_terms_of_use.html.\n\t\t\teasing: {\n\n\t\t\t\t// Deprecated\n\t\t\t\t\"ease-in\": function (time) {\n\t\t\t\t\treturn this.cubicBezier(0.42, 0, 1, 1, time);\n\t\t\t\t},\n\n\t\t\t\t// Deprecated\n\t\t\t\t\"ease-out\": function (time) {\n\t\t\t\t\treturn this.cubicBezier(0, 0, 0.58, 1, time);\n\t\t\t\t},\n\n\t\t\t\t// Deprecated\n\t\t\t\t\"ease-in-out\": function (time) {\n\t\t\t\t\treturn this.cubicBezier(0.42, 0, 0.58, 1, time);\n\t\t\t\t},\n\n\t\t\t\t// Deprecated syntax, will adopt the t, b, c, d syntax as the rest\n\t\t\t\t\"linear\": function (time) {\n\t\t\t\t\treturn time;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-quad\": function (t, b, c, d) {\n\t\t\t\t\treturn c*(t/=d)*t + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-quad\": function (t, b, c, d) {\n\t\t\t\t\treturn -c *(t/=d)*(t-2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-quad\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2*t*t + b;\n\t\t\t\t\treturn -c/2 * ((--t)*(t-2) - 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-cubic\": function (t, b, c, d) {\n\t\t\t\t\treturn c*(t/=d)*t*t + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-cubic\": function (t, b, c, d) {\n\t\t\t\t\treturn c*((t=t/d-1)*t*t + 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-cubic\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t + b;\n\t\t\t\t\treturn c/2*((t-=2)*t*t + 2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-quart\": function (t, b, c, d) {\n\t\t\t\t\treturn c*(t/=d)*t*t*t + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-quart\": function (t, b, c, d) {\n\t\t\t\t\treturn -c * ((t=t/d-1)*t*t*t - 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-quart\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t*t + b;\n\t\t\t\t\treturn -c/2 * ((t-=2)*t*t*t - 2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-quint\": function (t, b, c, d) {\n\t\t\t\t\treturn c*(t/=d)*t*t*t*t + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-quint\": function (t, b, c, d) {\n\t\t\t\t\treturn c*((t=t/d-1)*t*t*t*t + 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-quint\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;\n\t\t\t\t\treturn c/2*((t-=2)*t*t*t*t + 2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-sine\": function (t, b, c, d) {\n\t\t\t\t\treturn -c * Math.cos(t/d * (Math.PI/2)) + c + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-sine\": function (t, b, c, d) {\n\t\t\t\t\treturn c * Math.sin(t/d * (Math.PI/2)) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-sine\": function (t, b, c, d) {\n\t\t\t\t\treturn -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-expo\": function (t, b, c, d) {\n\t\t\t\t\treturn (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-expo\": function (t, b, c, d) {\n\t\t\t\t\treturn (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-expo\": function (t, b, c, d) {\n\t\t\t\t\tif (t==0) return b;\n\t\t\t\t\tif (t==d) return b+c;\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;\n\t\t\t\t\treturn c/2 * (-Math.pow(2, -10 * --t) + 2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-circ\": function (t, b, c, d) {\n\t\t\t\t\treturn -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-circ\": function (t, b, c, d) {\n\t\t\t\t\treturn c * Math.sqrt(1 - (t=t/d-1)*t) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-circ\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;\n\t\t\t\t\treturn c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-elastic\": function (t, b, c, d, a, p) {\n\t\t\t\t\ta = a || 0;\n\t\t\t\t\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\n\t\t\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\t\t\treturn -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-elastic\": function (t, b, c, d, a, p) {\n\t\t\t\t\ta = a || 0;\n\t\t\t\t\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\n\t\t\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\t\t\treturn a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-elastic\": function (t, b, c, d, a, p) {\n\t\t\t\t\ta = a || 0;\n\t\t\t\t\tif (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);\n\t\t\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\t\t\tif (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\n\t\t\t\t\treturn a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-back\": function (t, b, c, d, s) {\n\t\t\t\t\tif (s == undefined) s = 1.70158;\n\t\t\t\t\treturn c*(t/=d)*t*((s+1)*t - s) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-back\": function (t, b, c, d, s) {\n\t\t\t\t\tif (s == undefined) s = 1.70158;\n\t\t\t\t\treturn c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-back\": function (t, b, c, d, s) {\n\t\t\t\t\tif (s == undefined) s = 1.70158;\n\t\t\t\t\tif ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;\n\t\t\t\t\treturn c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-bounce\": function (t, b, c, d) {\n\t\t\t\t\treturn c - this[\"ease-out-bounce\"](d-t, 0, c, d) + b;\n\t\t\t\t},\n\n\t\t\t\t\"ease-out-bounce\": function (t, b, c, d) {\n\t\t\t\t\tif ((t/=d) < (1/2.75)) {\n\t\t\t\t\t\treturn c*(7.5625*t*t) + b;\n\t\t\t\t\t} else if (t < (2/2.75)) {\n\t\t\t\t\t\treturn c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;\n\t\t\t\t\t} else if (t < (2.5/2.75)) {\n\t\t\t\t\t\treturn c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t\"ease-in-out-bounce\": function (t, b, c, d) {\n\t\t\t\t\tif (t < d/2) return this[\"ease-in-bounce\"](t*2, 0, c, d) * .5 + b;\n\t\t\t\t\treturn this[\"ease-out-bounce\"](t*2-d, 0, c, d) * .5 + c*.5 + b;\n\t\t\t\t},\n\n\t\t\t\t// Deprecated, will be replaced by the new syntax for calling easing functions\n\t\t\t\tcubicBezier: function (x1, y1, x2, y2, time) {\n\n\t\t\t\t\t// Inspired by Don Lancaster's two articles\n\t\t\t\t\t// http://www.tinaja.com/glib/cubemath.pdf\n\t\t\t\t\t// http://www.tinaja.com/text/bezmath.html\n\n\n\t\t\t\t\t\t// Set start and end point\n\t\t\t\t\tvar x0 = 0,\n\t\t\t\t\t\ty0 = 0,\n\t\t\t\t\t\tx3 = 1,\n\t\t\t\t\t\ty3 = 1,\n\n\t\t\t\t\t\t// Convert the coordinates to equation space\n\t\t\t\t\t\tA = x3 - 3*x2 + 3*x1 - x0,\n\t\t\t\t\t\tB = 3*x2 - 6*x1 + 3*x0,\n\t\t\t\t\t\tC = 3*x1 - 3*x0,\n\t\t\t\t\t\tD = x0,\n\t\t\t\t\t\tE = y3 - 3*y2 + 3*y1 - y0,\n\t\t\t\t\t\tF = 3*y2 - 6*y1 + 3*y0,\n\t\t\t\t\t\tG = 3*y1 - 3*y0,\n\t\t\t\t\t\tH = y0,\n\n\t\t\t\t\t\t// Variables for the loop below\n\t\t\t\t\t\tt = time,\n\t\t\t\t\t\titerations = 5,\n\t\t\t\t\t\ti, slope, x, y;\n\n\t\t\t\t\t// Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n\t\t\t\t\t// http://en.wikipedia.org/wiki/Newton's_method\n\t\t\t\t\tfor (i = 0; i < iterations; i++) {\n\n\t\t\t\t\t\t// The curve's x equation for the current time value\n\t\t\t\t\t\tx = A* t*t*t + B*t*t + C*t + D;\n\n\t\t\t\t\t\t// The slope we want is the inverse of the derivate of x\n\t\t\t\t\t\tslope = 1 / (3*A*t*t + 2*B*t + C);\n\n\t\t\t\t\t\t// Get the next estimated time value, which will be more accurate than the one before\n\t\t\t\t\t\tt -= (x - time) * slope;\n\t\t\t\t\t\tt = t > 1 ? 1 : (t < 0 ? 0 : t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find the y value through the curve's y equation, with the now more accurate time value\n\t\t\t\t\ty = Math.abs(E*t*t*t + F*t*t + G*t * H);\n\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\treturn module;\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"animation\", animation);\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/animation.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/background.js":
/*!************************************************!*\
  !*** ./node_modules/ocanvas/src/background.js ***!
  \************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar background = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\t// Set properties\n\t\t\tbg: \"\",\n\t\t\tvalue: \"\",\n\t\t\ttype: \"transparent\",\n\t\t\tloaded: false,\n\t\t\t\n\t\t\tinit: function () {\n\t\t\t\tthis.set(this.core.settings.background);\n\t\t\t},\n\t\t\t\n\t\t\t// Method for setting the background\n\t\t\tset: function (value) {\n\t\t\t\tvar _this = this;\n\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.value = value;\n\t\t\t\t\n\t\t\t\t// Get background type (gradient, image, color or transparent)\n\t\t\t\tif (~value.indexOf(\"gradient\")) {\n\t\t\t\t\tthis.type = \"gradient\";\n\t\t\t\t} else if (~value.indexOf(\"image\")) {\n\t\t\t\t\tthis.type = \"image\";\n\t\t\t\t} else if (this.core.style && this.core.style.isColor(value)) {\n\t\t\t\t\tthis.type = \"color\";\n\t\t\t\t} else {\n\t\t\t\t\tthis.type = \"transparent\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Handle the different background types\n\t\t\t\tif (this.type === \"color\") {\n\t\t\t\t\n\t\t\t\t\t// Set color as background\n\t\t\t\t\tthis.bg = value;\n\t\t\t\t\tif (this.core.timeline && !this.core.timeline.running) {\n\t\t\t\t\t\tthis.core.draw.redraw(true);\n\t\t\t\t\t}\n\t\t\t\t\tthis.loaded = true;\n\t\t\t\t}\n\t\t\t\telse if (this.type === \"gradient\") {\n\t\t\t\t\n\t\t\t\t\t// Get gradient object and set it as background\n\t\t\t\t\tthis.bg = this.core.style ? this.core.style.getGradient(value, 0, 0, this.core.width, this.core.height) : \"\";\n\t\t\t\t\tif (this.core.timeline && !this.core.timeline.running) {\n\t\t\t\t\t\tthis.core.draw.redraw(true);\n\t\t\t\t\t}\n\t\t\t\t\tthis.loaded = true;\n\t\t\t\t}\n\t\t\t\telse if (this.type === \"image\") {\n\t\t\t\t\n\t\t\t\t\t// Parse image string\n\t\t\t\t\tvar matches = /image\\((.*?)(,(\\s|)(repeat|repeat-x|repeat-y|no-repeat)|)\\)/.exec(value),\n\t\t\t\t\t\tpath = matches[1],\n\t\t\t\t\t\trepeat = matches[4] || \"repeat\",\n\t\t\t\t\t\timage = new Image();\n\t\t\t\t\n\t\t\t\t\t// Set image as background\n\t\t\t\t\timage.src = path;\n\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\t_this.bg = _this.core.canvas.createPattern(this, repeat);\n\t\t\t\t\t\t_this.loaded = true;\n\t\t\t\t\t\tif (_this.core.timeline && !_this.core.timeline.running) {\n\t\t\t\t\t\t\t_this.core.redraw(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse {\n\t\t\t\t\t// Background type is transparent, redraw the background (clears the canvas)\n\t\t\t\t\tthis.redraw(true);\n\t\t\t\t\tthis.loaded = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for redrawing the background (replaces everything thas has been drawn)\n\t\t\tredraw: function () {\n\t\t\t\tvar core = this.core;\n\t\t\t\t\n\t\t\t\t// Fill canvas with the background color if it's not transparent\n\t\t\t\tif (this.type !== \"transparent\") {\n\t\t\t\t\tcore.canvas.fillStyle = this.bg;\n\t\t\t\t\tcore.canvas.fillRect(0, 0, core.width, core.height);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"background\", background, \"init\");\n\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/background.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/core.js":
/*!******************************************!*\
  !*** ./node_modules/ocanvas/src/core.js ***!
  \******************************************/
/***/ (() => {

eval("(function(window, document, undefined){\n\n\t// Define the oCanvas object\n\tvar oCanvas = {\n\t    \n\t\t// Version number of this oCanvas release.\n\t\tversion: \"2.10.0\",\n\t\t\n\t\t// Array containing all canvases created by oCanvas on the current page\n\t\tcanvasList: [],\n\t\t\n\t\t// Object containing all the registered modules\n\t\tmodules: {},\n\t\t\n\t\t// Object containing all the registered init methods\n\t\tinits: {},\n\t\t\n\t\t// Object containing all the registered plugins\n\t\tplugins: {},\n\t\t\n\t\t// Define the core class\n\t\tcore: function (options) {\n\t\t\tthis.isCore = true;\n\t\t\n\t\t\t// Add the canvas to the canvas list on the global object\n\t\t\tthis.id = oCanvas.canvasList.push(this) - 1;\n\t\t\t\n\t\t\t// A number which is used to give new objects an ID\n\t\t\tthis.lastObjectID = 0;\n\n\t\t\t// Initialize a list of all objects added directly to the canvas\n\t\t\tthis.children = [];\n\n\t\t\t// Initialize a list of all DOM event handlers\n\t\t\tthis.domEventHandlers = [];\n\t\t\t\n\t\t\t// Add the registered modules to the new instance of core\n\t\t\tfor (var m in oCanvas.modules) {\n\t\t\t\tif (typeof oCanvas.modules[m] === \"function\") {\n\t\t\t\t\tthis[m] = oCanvas.modules[m]();\n\t\t\t\t} else {\n\t\t\t\t\tthis[m] = Object.create(oCanvas.modules[m]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Set up default settings\n\t\t\tthis.settings = {\n\t\t\t\tfps: 30, // Deprecated value, will soon be changed to 60\n\t\t\t\tbackground: \"transparent\",\n\t\t\t\tclearEachFrame: true,\n\t\t\t\tdrawEachFrame: true,\n\t\t\t\tdisableScrolling: false,\n\t\t\t\tplugins: []\n\t\t\t};\n\n\t\t\t// Update the settings with the user specified settings\n\t\t\toCanvas.extend(this.settings, options);\n\n\t\t\t// Save these settings in case the core instance is reset\n\t\t\tthis.originalSettings = oCanvas.extend({}, this.settings);\n\t\t\t\n\t\t\t// Set canvas to specified element\n\t\t\tif (this.settings.canvas.nodeName && this.settings.canvas.nodeName.toLowerCase() === \"canvas\") {\n\t\t\t\tthis.canvasElement = this.settings.canvas;\n\t\t\t}\n\t\t\t\n\t\t\t// Set canvas to the element specified using a selector\n\t\t\telse if (typeof this.settings.canvas === \"string\") {\n\t\t\t\tthis.canvasElement = document.querySelector(this.settings.canvas);\n\t\t\t}\n\t\t\t\n\t\t\t// Return false if no canvas was specified\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// Get the canvas context and dimensions\n\t\t\tthis.canvas = this.canvasElement.getContext(\"2d\");\n\t\t\tvar width = this.canvasElement.width;\n\t\t\tvar height = this.canvasElement.height;\n\t\t\tObject.defineProperty(this, \"width\", {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tset: function (value) {\n\t\t\t\t\twidth = !isNaN(parseFloat(value)) ? parseFloat(value) : width;\n\t\t\t\t\tthis.canvasElement.width = width;\n\t\t\t\t\tthis.background.set(this.settings.background);\n\t\t\t\t\tthis.redraw();\n\t\t\t\t},\n\t\t\t\tget: function () {\n\t\t\t\t\treturn width;\n\t\t\t\t}\n\t\t\t});\n\t\t\tObject.defineProperty(this, \"height\", {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tset: function (value) {\n\t\t\t\t\theight = !isNaN(parseFloat(value)) ? parseFloat(value) : height;\n\t\t\t\t\tthis.canvasElement.height = height;\n\t\t\t\t\tthis.background.set(this.settings.background);\n\t\t\t\t\tthis.redraw();\n\t\t\t\t},\n\t\t\t\tget: function () {\n\t\t\t\t\treturn height;\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\t\t// Set the core instance in all modules to enable access of core properties inside of modules\n\t\t\tfor (var m in oCanvas.modules) {\n\t\t\t\n\t\t\t\t// Add core access to modules in a wrapper module (like display objects that reside in the wrapper display)\n\t\t\t\tif (this[m].wrapper === true) {\n\t\t\t\t\tfor (var wm in this[m]) {\n\t\t\t\t\t\tif (typeof this[m][wm] === \"object\" && typeof this[m][wm].setCore === \"function\") {\n\t\t\t\t\t\t\tthis[m][wm] = this[m][wm].setCore(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof this[m][wm].setCore === \"function\") {\n\t\t\t\t\t\t\tthis[m][wm].setCore(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis[m].core = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add core access to modules that reside directly in the core\n\t\t\t\tthis[m].core = this;\n\t\t\t}\n\t\t\t\n\t\t\t// Initialize added modules that have registered init methods\n\t\t\tfor (var name in oCanvas.inits) {\n\t\t\t\n\t\t\t\t// Modules directly on the oCanvas object\n\t\t\t\tif ((typeof oCanvas.inits[name] === \"string\") && (typeof this[name][oCanvas.inits[name]] === \"function\")) {\n\t\t\t\t\tthis[name][oCanvas.inits[name]]();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Modules that are parts of a wrapper module\n\t\t\t\telse if (oCanvas.inits[name] === \"object\") {\n\t\t\t\t\tfor (var subname in oCanvas.inits[name]) {\n\t\t\t\t\t\tif (typeof this[name][oCanvas.inits[name][subname]] === \"function\") {\n\t\t\t\t\t\t\tthis[name][oCanvas.inits[name][subname]]();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Run plugins if any have been specified\n\t\t\tvar plugins = this.settings.plugins;\n\t\t\tif (plugins.length > 0) {\n\t\t\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\n\t\t\t\t\tif (typeof oCanvas.plugins[plugins[i]] === \"function\") {\n\t\t\t\t\t\toCanvas.plugins[plugins[i]].call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t// Method for registering a new module\n\t\tregisterModule: function (name, module, init) {\n\t\t\tif (~name.indexOf(\".\")) {\n\t\t\t\tvar parts = name.split(\".\");\n\t\t\t\toCanvas.modules[parts[0]][parts[1]] = module;\n\t\t\t\t\n\t\t\t\tif (init !== undefined) {\n\t\t\t\t\tif (!oCanvas.inits[parts[0]]) {\n\t\t\t\t\t\toCanvas.inits[parts[0]] = {};\n\t\t\t\t\t}\n\t\t\t\t\toCanvas.inits[parts[0]][parts[1]] = init;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toCanvas.modules[name] = module;\n\t\t\t\tif (init !== undefined) {\n\t\t\t\t\toCanvas.inits[name] = init;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t// Method for registering a new plugin\n\t\t// The plugin will not be run until a new core instance is being created,\n\t\t// and the instance requests the plugin, thus allowing a plugin to change\n\t\t// things in the library for just one instance\n\t\tregisterPlugin: function (name, plugin) {\n\t\t\toCanvas.plugins[name] = plugin;\n\t\t},\n\t\t\n\t\t// Function for creating a new instance of oCanvas\n\t\tcreate: function (settings) {\n\t\t\n\t\t\t// Create the new instance and return it\n\t\t\treturn new oCanvas.core(settings);\n\t\t},\n\n\t\t// Function for checking when the DOM is ready for interaction\n\t\tdomReady: function (func) {\n\t\t\tfunc = func || function () {};\n\n\t\t\tthis.domReadyHandlers.push(func);\n\n\t\t\tif (this.isDomReadyListening) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.isDomReady) {\n\t\t\t\toCanvas.triggerDomReadyHandlers();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar checkState = function (e) {\n\t\t\t\tif (document.readyState === \"complete\" || (e && e.type === \"DOMContentLoaded\")) {\n\t\t\t\t\toCanvas.isDomReadyListening = false;\n\t\t\t\t\toCanvas.isDomReady = true;\n\t\t\t\t\toCanvas.triggerDomReadyHandlers();\n\t\t\t\t\tdocument.removeEventListener(\"readystatechange\", checkState, false);\n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", checkState, false);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (checkState()) {\n\t\t\t\treturn true;\n\t\t\t} else if (!this.isDomReadyListening) {\n\t\t\t\toCanvas.isDomReadyListening = true;\n\t\t\t\tdocument.addEventListener(\"readystatechange\", checkState, false);\n\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", checkState, false);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tisDomReady: false,\n\t\tisDomReadyListening: false,\n\t\tdomReadyHandlers: [],\n\t\ttriggerDomReadyHandlers: function () {\n\t\t\tvar handlers, i, l, handler;\n\t\t\thandlers = this.domReadyHandlers;\n\t\t\tfor (i = 0, l = handlers.length; i < l; i++) {\n\t\t\t\thandler = handlers[i];\n\t\t\t\tif (handler) {\n\t\t\t\t\tdelete handlers[i];\n\t\t\t\t\thandler();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t};\n\t\n\t\n\t// Methods the core instances will have access to\n\toCanvas.core.prototype = {\n\t\t\n\t\t// Method for adding an object to the canvas\n\t\taddChild: function (displayobj, redraw) {\n\t\t\tdisplayobj.add(redraw);\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\n\t\t// Method for adding an object to the canvas at a specific index\n\t\t// If index < 0, then the child is added to the beginning of children array\n\t\t// If index >= children.length, then the child is added at the end of children array\n\t\taddChildAt: function (displayobj, index, redraw) {\n\t\t\tdisplayobj.addAt(index, redraw);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Method for removing an object from the canvas\n\t\tremoveChild: function (displayobj, redraw) {\n\t\t\tdisplayobj.remove(redraw);\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\n\t\t// Method for removing a child at a specific index\n\t\tremoveChildAt: function (index, redraw) {\n\t\t\tif (this.children[index] !== undefined) {\n\t\t\t\tthis.children[index].remove(redraw);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Shorthand method for clearing the canvas\n\t\tclear: function (keepBackground) {\n\t\t\tthis.draw.clear(keepBackground);\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t// Shorthand method for redrawing the canvas\n\t\tredraw: function () {\n\t\t\tthis.draw.redraw();\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t// Method for binding an event to the canvas\n\t\tbind: function (types, handler) {\n\t\t\tthis.events.bind(this.canvasElement, types.split(\" \"), handler);\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t// Method for unbinding an event from the object\n\t\tunbind: function (types, handler) {\n\t\t\tthis.events.unbind(this.canvasElement, types.split(\" \"), handler);\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\t\n\t\t// Method for triggering all events added to the object\n\t\ttrigger: function (types, eventObject) {\n\t\t\tvar events = this.events;\n\t\t\tevents.triggerHandlers(this.canvasElement, types.split(\" \"), events.fixEventObject(eventObject));\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Method for resetting the core instance to its initial state\n\t\treset: function () {\n\n\t\t\t// Remove all objects\n\t\t\tvar children = this.children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].remove();\n\t\t\t\ti--; l--;\n\t\t\t}\n\t\t\tchildren.length = 0;\n\t\t\tthis.lastObjectID = 0;\n\n\t\t\t// Remove all oCanvas event handlers\n\t\t\tvar eventTypes = this.canvasElement.events;\n\t\t\tfor (var type in eventTypes) {\n\t\t\t\tif (eventTypes[type] instanceof Array) {\n\t\t\t\t\tthis.unbind(type, eventTypes[type]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reset the settings\n\t\t\tthis.settings = oCanvas.extend({}, this.originalSettings);\n\t\t},\n\n\t\t// Method for destroying the core instance, to clear up memory etc\n\t\tdestroy: function () {\n\t\t\tif (this.timeline) {\n\t\t\t\tthis.timeline.stop();\n\t\t\t}\n\n\t\t\tthis.reset();\n\n\t\t\t// Remove all DOM event handlers\n\t\t\tfor (var i = 0, l = this.domEventHandlers.length; i < l; i++) {\n\t\t\t\toCanvas.removeDOMEventHandler(this, i);\n\t\t\t}\n\t\t\tthis.domEventHandlers.length = 0;\n\n\t\t\t// Remove the core instance from the global list of core instances\n\t\t\toCanvas.canvasList[this.id] = null;\n\n\t\t\t// Cut any connection to the previous canvas element by creating a new\n\t\t\t// canvas. This avoids leakage in case some part of the library or a\n\t\t\t// plugin is still calling things on the core instance.\n\t\t\tthis.canvasElement = document.createElement(\"canvas\");\n\t\t\tthis.canvas = this.canvasElement.getContext(\"2d\");\n\t\t}\n\t};\n\n\t// Attach the oCanvas object to the window object for access outside of this file\n\twindow.oCanvas = oCanvas;\n\n\toCanvas.domReady();\n\t\n})(window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/core.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobject.js":
/*!***************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobject.js ***!
  \***************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar displayObject = function () {\n\t\n\t\t// Method for setting a stroke property. Updates both obj.stroke and obj.property\n\t\tvar setStrokeProperty = function (_this, property, value, objectProperty, thecore) {\n\t\t\tvar stroke = thecore.style.getStroke(_this.stroke);\n\t\t\tstroke[property] = value;\n\t\t\t_this.stroke = thecore.style.getStroke(stroke, \"string\");\n\t\t};\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\t// Properties\n\t\t\tid: 0,\n\t\t\tshapeType: \"rectangular\",\n\t\t\ttype: \"\",\n\t\t\torigin: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t},\n\t\t\tevents: {},\n\t\t\tchildren: [],\n\t\t\tadded: false,\n\t\t\topacity: 1,\n\t\t\trotation: 0,\n\t\t\tcomposition: \"source-over\",\n\t\t\tscalingX: 1,\n\t\t\tscalingY: 1,\n\t\t\tpointerEvents: true,\n\t\t\tanimationQueues: {},\n\t\t\t\n\t\t\t_: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tabs_x: 0,\n\t\t\t\tabs_y: 0,\n\t\t\t\trotation: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tdrawn: false,\n\t\t\t\tstroke: \"\",\n\t\t\t\tstrokeColor: \"black\",\n\t\t\t\tstrokeWidth: 0,\n\t\t\t\tstrokePosition: \"center\",\n\t\t\t\tcap: \"butt\",\n\t\t\t\tjoin: \"miter\",\n\t\t\t\tmiterLimit: 10,\n\t\t\t\tfill: \"\",\n\t\t\t\tshadow: {\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\tblur: 0,\n\t\t\t\t\tcolor: \"transparent\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\tset strokeColor (color) {\n\t\t\t\tsetStrokeProperty(this, \"color\", color, \"strokeColor\", this.core);\n\t\t\t},\n\t\t\tset strokeWidth (width) {\n\t\t\t\tsetStrokeProperty(this, \"width\", width, \"strokeWidth\", this.core);\n\t\t\t},\n\t\t\tset strokePosition (pos) {\n\t\t\t\tsetStrokeProperty(this, \"pos\", pos, \"strokePosition\", this.core);\n\t\t\t},\n\t\t\tset stroke (value) {\n\t\t\t\n\t\t\t\t// Convert the value to a correct string if it is not a string\n\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\tvalue = this.core.style.getStroke(value, \"string\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get stroke object and set styles\n\t\t\t\tvar stroke = this.core.style.getStroke(value);\n\t\t\t\t\n\t\t\t\t// Handle patterns\n\t\t\t\tif (~stroke.color.indexOf(\"image(\")) {\n\t\t\t\t\tvar matches = /image\\((.*?)(,(\\s|)(repeat|repeat-x|repeat-y|no-repeat)|)\\)/.exec(stroke.color),\n\t\t\t\t\t\tpath = matches[1],\n\t\t\t\t\t\trepeat = matches[4] || \"repeat\",\n\t\t\t\t\t\timage = new Image(),\n\t\t\t\t\t\t_this = this;\n\t\t\t\t\t\t\n\t\t\t\t\timage.src = path;\n\t\t\t\t\tthis._.strokepattern_loading = true;\n\t\t\t\t\tthis._.strokepattern_redraw = false;\n\t\t\t\t\t\n\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\t_this._.strokeColor = _this.core.canvas.createPattern(this, repeat);\n\t\t\t\t\t\t_this._.strokepattern_loading = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (_this._.strokepattern_redraw) {\n\t\t\t\t\t\t\t_this._.strokepattern_redraw = false;\n\t\t\t\t\t\t\t_this.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthis._.strokeColor = stroke.color;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set other stroke properties\n\t\t\t\tthis._.strokeWidth = stroke.width;\n\t\t\t\tthis._.strokePosition = stroke.pos;\n\t\t\t\tthis._.stroke = value;\n\t\t\t},\n\t\t\tset cap (value) {\n\t\t\t\tvar possible_values = [\"butt\", \"round\", \"square\"];\n\t\t\t\tthis._.cap = ~possible_values.indexOf(value) ? value : \"butt\";\n\t\t\t},\n\t\t\tset join (value) {\n\t\t\t\tvar possible_values = [\"round\", \"bevel\", \"miter\"];\n\t\t\t\tthis._.join = ~possible_values.indexOf(value) ? value : \"miter\";\n\t\t\t},\n\t\t\tset miterLimit (value) {\n\t\t\t\tthis._.miterLimit = !isNaN(parseFloat(value)) ? parseFloat(value) : 10;\n\t\t\t},\n\t\t\tget stroke () {\n\t\t\t\treturn this._.stroke;\n\t\t\t},\n\t\t\tget strokeColor () {\n\t\t\t\tif (this._.strokepattern_loading) {\n\t\t\t\t\tthis._.strokepattern_redraw = true;\n\t\t\t\t\treturn \"\";\n\t\t\t\t} else if (~this._.strokeColor.toString().indexOf(\"CanvasPattern\")) {\n\t\t\t\t\treturn this._.strokeColor;\n\t\t\t\t} else if (~this._.strokeColor.indexOf(\"gradient\")) {\n\t\t\t\t\tvar origin = this.getOrigin();\n\t\t\t\t\tif (this.shapeType === \"rectangular\") {\n\t\t\t\t\t\tvar stroke = (this.strokePosition === \"outside\") ? this.strokeWidth : (this.strokePosition === \"center\" ? this.strokeWidth / 2 : 0);\n\t\t\t\t\t\treturn this.core.style.getGradient(this._.strokeColor, this.abs_x - origin.x - stroke, this.abs_y - origin.y - stroke, this.width + stroke * 2, this.height + stroke * 2);\n\t\t\t\t\t} else if (this.shapeType === \"radial\") {\n\t\t\t\t\t\tvar radius = this.radius + this.strokeWidth / 2;\n\t\t\t\t\t\torigin.x += this.radius;\n\t\t\t\t\t\torigin.y += this.radius;\n\t\t\t\t\t\treturn this.core.style.getGradient(this._.strokeColor, this.abs_x - origin.x - this.radius, this.abs_y - origin.y - this.radius, radius * 2, radius * 2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this._.strokeColor;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget strokeWidth () {\n\t\t\t\treturn this._.strokeWidth;\n\t\t\t},\n\t\t\tget strokePosition () {\n\t\t\t\treturn this._.strokePosition;\n\t\t\t},\n\t\t\tget cap () {\n\t\t\t\treturn this._.cap;\n\t\t\t},\n\t\t\tget join () {\n\t\t\t\treturn this._.join;\n\t\t\t},\n\t\t\tget miterLimit () {\n\t\t\t\treturn this._.miterLimit;\n\t\t\t},\n\t\t\t\n\t\t\tset fill (value) {\n\t\t\t\tif (~value.indexOf(\"image(\")) {\n\t\t\t\t\tvar matches = /image\\((.*?)(,(\\s|)(repeat|repeat-x|repeat-y|no-repeat)|)\\)/.exec(value),\n\t\t\t\t\t\tpath = matches[1],\n\t\t\t\t\t\trepeat = matches[4] || \"repeat\",\n\t\t\t\t\t\timage = new Image(),\n\t\t\t\t\t\t_this = this;\n\t\t\t\t\t\t\n\t\t\t\t\timage.src = path;\n\t\t\t\t\tthis._.pattern_loading = true;\n\t\t\t\t\tthis._.pattern_redraw = false;\n\t\t\t\t\t\n\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\t_this._.fill = _this.core.canvas.createPattern(this, repeat);\n\t\t\t\t\t\t_this._.pattern_loading = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (_this._.pattern_redraw) {\n\t\t\t\t\t\t\t_this._.pattern_redraw = false;\n\t\t\t\t\t\t\t_this.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthis._.fill = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget fill () {\n\t\t\t\tif (this._.pattern_loading) {\n\t\t\t\t\tthis._.pattern_redraw = true;\n\t\t\t\t\treturn \"\";\n\t\t\t\t} else if (~this._.fill.toString().indexOf(\"CanvasPattern\")) {\n\t\t\t\t\treturn this._.fill;\n\t\t\t\t} else if (~this._.fill.indexOf(\"gradient\")) {\n\t\t\t\t\tvar origin = this.getOrigin();\n\t\t\t\t\tif (this.shapeType === \"rectangular\") {\n\t\t\t\t\t\treturn this.core.style.getGradient(this._.fill, this.abs_x - origin.x, this.abs_y - origin.y, this.width, this.height);\n\t\t\t\t\t} else if (this.shapeType === \"radial\") {\n\t\t\t\t\t\treturn this.core.style.getGradient(this._.fill, this.abs_x - origin.x - this.radius, this.abs_y - origin.y - this.radius, this.radius * 2, this.radius * 2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this._.fill;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset shadow (value) {\n\t\t\t\n\t\t\t\t// Convert the value to a correct string if it is not a string\n\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\tvalue = this.core.style.getShadow(value, \"string\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get shadow object and set styles\n\t\t\t\tvar shadow = this.core.style.getShadow(value);\n\t\t\t\tthis._.shadow = shadow;\n\t\t\t},\n\t\t\tset shadowOffsetX (value) {\n\t\t\t\tif (!isNaN(parseFloat(value))) {\n\t\t\t\t\tthis._.shadow.offsetX = parseFloat(value);\n\t\t\t\t}\n\t\t\t},\n\t\t\tset shadowOffsetY (value) {\n\t\t\t\tif (!isNaN(parseFloat(value))) {\n\t\t\t\t\tthis._.shadow.offsetY = parseFloat(value);\n\t\t\t\t}\n\t\t\t},\n\t\t\tset shadowBlur (value) {\n\t\t\t\tif (!isNaN(parseFloat(value))) {\n\t\t\t\t\tthis._.shadow.blur = parseFloat(value);\n\t\t\t\t}\n\t\t\t},\n\t\t\tset shadowColor (value) {\n\t\t\t\tif (this.core.style.isColor(value)) {\n\t\t\t\t\tthis._.shadow.color = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget shadow () {\n\t\t\t\treturn this._.shadow;\n\t\t\t},\n\t\t\tget shadowOffsetX () {\n\t\t\t\treturn this._.shadow.offsetX;\n\t\t\t},\n\t\t\tget shadowOffsetY () {\n\t\t\t\treturn this._.shadow.offsetY;\n\t\t\t},\n\t\t\tget shadowBlur () {\n\t\t\t\treturn this._.shadow.blur;\n\t\t\t},\n\t\t\tget shadowColor () {\n\t\t\t\treturn this._.shadow.color;\n\t\t\t},\n\t\t\t\n\t\t\tset x (value) {\n\t\t\t\tthis._.x = value;\n\t\t\t\tthis._.abs_x = value + ((this.parent !== undefined && this.parent !== this.core) ? this.parent.abs_x : 0);\n\t\t\t\t\n\t\t\t\t// Update children\n\t\t\t\tvar objects = this.children,\n\t\t\t\t\tl = objects.length, i;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tobjects[i]._.abs_x = this.abs_x + objects[i].x;\n\t\t\t\t\tobjects[i].x += 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset y (value) {\n\t\t\t\tthis._.y = value;\n\t\t\t\tthis._.abs_y = value + ((this.parent !== undefined && this.parent !== this.core) ? this.parent.abs_y : 0);\n\t\t\t\t\n\t\t\t\t// Update children\n\t\t\t\tvar objects = this.children,\n\t\t\t\t\tl = objects.length, i;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tobjects[i]._.abs_y = this.abs_y - objects[i].y;\n\t\t\t\t\tobjects[i].y += 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget x () {\n\t\t\t\treturn this._.x;\n\t\t\t},\n\t\t\tget y () {\n\t\t\t\treturn this._.y;\n\t\t\t},\n\t\t\tset abs_x (value) {\n\t\t\t\treturn;\n\t\t\t},\n\t\t\tset abs_y (value) {\n\t\t\t\treturn;\n\t\t\t},\n\t\t\tget abs_x () {\n\t\t\t\treturn this._.abs_x;\n\t\t\t},\n\t\t\tget abs_y () {\n\t\t\t\treturn this._.abs_y;\n\t\t\t},\n\t\t\tset width (value) {\n\t\t\t\tthis._.width = value;\n\t\t\t},\n\t\t\tget width () {\n\t\t\t\treturn this._.width;\n\t\t\t},\n\t\t\tset height (value) {\n\t\t\t\tthis._.height = value;\n\t\t\t},\n\t\t\tget height () {\n\t\t\t\treturn this._.height;\n\t\t\t},\n\t\t\tset zIndex (value) {\n\t\t\t\tif (!this.parent) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Get new z index based on keywords\n\t\t\t\tif (value === \"front\") {\n\t\t\t\t\tvalue = this.parent.children.length - 1;\n\t\t\t\t}\n\t\t\t\tif (value === \"back\") {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\n\t\t\t\t// Change the z order\n\t\t\t\tthis.core.draw.changeZorder(this.parent, this.zIndex, value);\n\t\t\t},\n\t\t\tget zIndex () {\n\t\t\t\treturn this.parent && this.parent.children.indexOf(this);\n\t\t\t},\n\t\t\tget drawn () {\n\t\t\t\treturn this.core.draw.isCleared ? false : this._.drawn;\n\t\t\t},\n\t\t\tset drawn (value) {\n\t\t\t\tthis._.drawn = !!value;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for binding an event to the object\n\t\t\tbind: function (types, handler) {\n\t\t\t\tthis.core.events.bind(this, types.split(\" \"), handler);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for unbinding an event from the object\n\t\t\tunbind: function (types, handler) {\n\t\t\t\tthis.core.events.unbind(this, types.split(\" \"), handler);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for triggering all events added to the object\n\t\t\ttrigger: function (types, eventObject) {\n\t\t\t\tvar events = this.core.events;\n\t\t\t\tvar chain = events.getParentChain(this, true, true);\n\t\t\t\tevents.triggerChain(chain, types.split(\" \"), events.fixEventObject(eventObject));\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for adding the object to the canvas\n\t\t\tadd: function (redraw) {\n\t\t\t\treturn this.addAt(this.core.children.length, redraw);\n\t\t\t},\n\n\t\t\t// Method for adding the object to the canvas at a specific index\n\t\t\t// If index < 0, then the child is added to the beginning of children array\n\t\t\t// If index >= children.length, then the child is added at the end of children array\n\t\t\taddAt: function (index, redraw) {\n\t\t\t\tif (!this.added) {\n\n\t\t\t\t\t// Redraw by default, but leave it to the user to decide\n\t\t\t\t\tredraw = redraw !== undefined ? redraw : true;\n\n\t\t\t\t\t// Add this object\n\t\t\t\t\tif (index >= this.core.children.length) {\n\t\t\t\t\t\tthis.core.children.push(this);\n\t\t\t\t\t} else if (index < 0) {\n\t\t\t\t\t\tthis.core.children.unshift(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.core.children.splice(index, 0, this);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.added = true;\n\t\t\t\t\tthis.parent = this.core;\n\n\t\t\t\t\t// Add it to a global list of all objects. Deprecated list, will be removed soon.\n\t\t\t\t\tthis.core.draw.objects.push(this);\n\n\t\t\t\t\t// Redraw the canvas with the new object\n\t\t\t\t\tif (redraw) {\n\t\t\t\t\t\tthis.core.draw.redraw();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Method for removing the object from the canvas\n\t\t\tremove: function (redraw) {\n\n\t\t\t\t// Redraw by default, but leave it to the user to decide\n\t\t\t\tredraw = redraw !== undefined ? redraw : true;\n\n\t\t\t\t// Abort if the object is not added to a parent object\n\t\t\t\tif (!this.parent) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Get the index for this object within the parent's child list\n\t\t\t\tvar index = this.parent.children.indexOf(this);\n\t\t\t\tif (~index) {\n\t\t\t\t\tthis.parent.children.splice(index, 1);\n\t\t\t\t\tthis.parent = undefined;\n\t\t\t\t\tthis.added = false;\n\t\t\t\t\tthis.drawn = false;\n\n\t\t\t\t\t// Remove it from a global list of all objects. Deprecated list, will be removed soon.\n\t\t\t\t\tvar index2 = this.core.draw.objects.indexOf(this);\n\t\t\t\t\tif (~index2) {\n\t\t\t\t\t\tthis.core.draw.objects.splice(i, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set draw state for children of this object\n\t\t\t\t\tvar objects = this.children;\n\t\t\t\t\tfor (var i = 0, l = objects.length; i < l; i++) {\n\t\t\t\t\t\tobjects[i].drawn = false;\n\t\t\t\t\t\tindex2 = this.core.draw.objects.indexOf(objects[i]);\n\t\t\t\t\t\tif (~index2) {\n\t\t\t\t\t\t\tthis.core.draw.objects.splice(index2, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Redraw the canvas to actually remove the object\n\t\t\t\t\tif (redraw) {\n\t\t\t\t\t\tthis.core.draw.redraw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for drawing the shape\n\t\t\tdraw: function () {\n\t\t\t\t\n\t\t\t},\n\t\t\t\n\t\t\t// Method for redrawing the canvas\n\t\t\tredraw: function () {\n\t\t\t\tthis.core.draw.redraw();\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for rotating the object\n\t\t\trotate: function (angle) {\n\t\t\t\tthis.rotation += angle;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for rotating to a specific angle\n\t\t\trotateTo: function (angle) {\n\t\t\t\tthis.rotation = angle;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for getting x/y arguments, with the ability to choose only one\n\t\t\t// Used by other methods\n\t\t\t//   Examples:\n\t\t\t//     obj.move(50, 100); // moves object 50px to the right and 100px down\n\t\t\t//     obj.move(50, \"x\"); // moves object 50px to the right\n\t\t\t//     obj.move(50); // moves object 50px to the right and down\n\t\t\tgetArgs: function (x, y, default_x, default_y) {\n\t\t\t\tdefault_x = default_x || 0;\n\t\t\t\tdefault_y = default_y || 0;\n\t\t\t\t\n\t\t\t\t// Second argument is string \n\t\t\t\tif (typeof y === \"string\") {\n\t\t\t\t\tvar type = y,\n\t\t\t\t\t\tval = x;\n\t\t\t\t\tx = (type === \"x\") ? val : default_x;\n\t\t\t\t\ty = (type === \"y\") ? val : default_y;\n\t\t\t\t}\n\t\t\t\telse if (y === undefined) {\n\t\t\t\t\ty = x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Method for moving the object\n\t\t\tmove: function (x, y) {\n\t\t\t\tvar change = this.getArgs(x, y);\n\t\t\t\tthis.x += change.x;\n\t\t\t\tthis.y += change.y;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for moving to a specific position\n\t\t\tmoveTo: function (x, y) {\n\t\t\t\tvar pos = this.getArgs(x, y, this.x, this.y);\n\t\t\t\tthis.x = pos.x;\n\t\t\t\tthis.y = pos.y;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for scaling the object\n\t\t\tscale: function (x, y) {\n\t\t\t\tvar scaling = this.getArgs(x, y, 1, 1);\n\t\t\t\tthis.scalingX = scaling.x;\n\t\t\t\tthis.scalingY = scaling.y;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for scaling to a specific size\n\t\t\tscaleTo: function (width, height) {\n\t\t\t\tvar currentWidth = (this.shapeType === \"rectangular\" ? this.width : this.radius),\n\t\t\t\t\tcurrentHeight = (this.shapeType === \"rectangular\" ? this.height : this.radius),\n\t\t\t\t\tsize = this.getArgs(width, height, currentWidth, currentHeight);\n\t\t\t\t\t\n\t\t\t\t// Don't let the size be 0, because the native scale method doesn't support zero values\n\t\t\t\tsize.x = size.x <= 0 ? 1 : size.x;\n\t\t\t\tsize.y = size.y <= 0 ? 1 : size.y;\n\t\t\t\t\n\t\t\t\t// Set the scaling\n\t\t\t\tthis.scalingX = size.x / currentWidth;\n\t\t\t\tthis.scalingY = size.y / currentHeight;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for animating any numeric property\n\t\t\tanimate: function () {\n\t\t\t\tthis.core.animation.animate(this, arguments);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for clearing the object's animation queue and stop the animations\n\t\t\tstop: function () {\n\t\t\t\tthis.core.animation.stop(this);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Method for clearing the animation queue and setting all final values\n\t\t\tfinish: function () {\n\t\t\t\tthis.core.animation.finish(this);\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Method for delaying the rest of the animation queue (queue arg is optional)\n\t\t\tdelay: function (duration, options) {\n\t\t\t\tthis.core.animation.delay(this, duration, options);\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for changing the opacity property to 1 as an animation\n\t\t\tfadeIn: function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\tthis.core.animation.animate(this, [{ opacity: 1 }].concat(args));\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for changing the opacity property to 0 as an animation\n\t\t\tfadeOut: function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\tthis.core.animation.animate(this, [{ opacity: 0 }].concat(args));\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for changing the opacity property to a custom value as an animation\n\t\t\tfadeTo: function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\tthis.core.animation.animate(this, [{ opacity: args.splice(0, 1)[0] }].concat(args));\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for making drag and drop easier\n\t\t\tdragAndDrop: function (options) {\n\t\t\t\n\t\t\t\toptions = (options === undefined) ? {} : options;\n\t\t\t\n\t\t\t\t// If false is passed as argument, remove all event handlers\n\t\t\t\tif (options === false && this.draggable === true) {\n\t\t\t\t\tthis.draggable = false;\n\t\t\t\t\t\n\t\t\t\t\tthis.unbind(\"mousedown touchstart\", this._.drag_start)\n\t\t\t\t\tthis.core.unbind(\"mouseup touchend\", this._.drag_end);\n\t\t\t\t\tthis.core.unbind(\"mousemove touchmove\", this._.drag_move);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Otherwise add event handlers, unless they have been added before\n\t\t\t\telse if (!this.draggable) {\n\t\t\t\t\n\t\t\t\t\tthis.draggable = true;\n\t\t\t\t\tthis.dragging = false;\n\t\t\t\t\n\t\t\t\t\tvar _this = this,\n\t\t\t\t\t\toffset = { x: 0, y: 0 },\n\t\t\t\t\t\tstartPos = { x: 0, y: 0 },\n\t\t\t\t\t\tstart = { x: 0, y: 0 };\n\t\t\t\t\t\n\t\t\t\t\tthis._.drag_start = function (e) {\n\n\t\t\t\t\t\t// Stop bubbling if specified\n\t\t\t\t\t\tif (options.bubble === false) {\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dragging = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the difference between pointer position and object position\n\t\t\t\t\t\toffset.x = e.x - this.x;\n\t\t\t\t\t\toffset.y = e.y - this.y;\n\t\t\t\t\t\tstartPos.x = this.x;\n\t\t\t\t\t\tstartPos.y = this.y;\n\t\t\t\t\t\tstart = _this.core.tools.transformPointerPosition(_this, _this.abs_x, _this.abs_y, _this.rotation);\n\n\t\t\t\t\t\t// Change Z index if specified\n\t\t\t\t\t\tif (options.changeZindex === true) {\n\t\t\t\t\t\t\tthis.zIndex = \"front\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Run user callback\n\t\t\t\t\t\tif (typeof options.start === \"function\") {\n\t\t\t\t\t\t\toptions.start.call(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Redraw the canvas if the timeline is not running\n\t\t\t\t\t\tif (!this.core.timeline.running) {\n\t\t\t\t\t\t\tthis.core.draw.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tthis._.drag_end = function (e) {\n\t\t\t\t\t\tif (_this.dragging) {\n\n\t\t\t\t\t\t\t// Stop bubbling if specified\n\t\t\t\t\t\t\tif (options.bubble === false) {\n\t\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_this.dragging = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Run user callback\n\t\t\t\t\t\t\tif (typeof options.end === \"function\") {\n\t\t\t\t\t\t\t\toptions.end.call(_this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Redraw the canvas if the timeline is not running\n\t\t\t\t\t\t\tif (!_this.core.timeline.running) {\n\t\t\t\t\t\t\t\t_this.core.draw.redraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tthis._.drag_move = function (e) {\n\t\t\t\t\t\tif (_this.dragging) {\n\n\t\t\t\t\t\t\t// Stop bubbling if specified\n\t\t\t\t\t\t\tif (options.bubble === false) {\n\t\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar end = _this.core.tools.transformPointerPosition(_this, _this.abs_x, _this.abs_y, _this.rotation);\n\n\t\t\t\t\t\t\t_this.x = startPos.x + end.x - start.x;\n\t\t\t\t\t\t\t_this.y = startPos.y + end.y - start.y;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Run user callback\n\t\t\t\t\t\t\tif (typeof options.move === \"function\") {\n\t\t\t\t\t\t\t\toptions.move.call(_this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Redraw the canvas if the timeline is not running\n\t\t\t\t\t\t\tif (!_this.core.timeline.running) {\n\t\t\t\t\t\t\t\t_this.core.draw.redraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// Bind event handlers\n\t\t\t\t\tthis.bind(\"mousedown touchstart\", this._.drag_start)\n\t\t\t\t\tthis.core.bind(\"mouseup touchend\", this._.drag_end);\n\t\t\t\t\tthis.core.bind(\"mousemove touchmove\", this._.drag_move);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for setting the origin coordinates\n\t\t\t// Accepts pixel values or the following keywords:\n\t\t\t//     x: left | center | right\n\t\t\t//     y: top | center | bottom\n\t\t\tsetOrigin: function (x, y) {\n\t\t\t\tthis.origin.x = x;\n\t\t\t\tthis.origin.y = y;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for getting the current origin coordinates in pixels\n\t\t\tgetOrigin: function () {\n\t\t\t\tvar x, y,\n\t\t\t\t\torigin = this.origin,\n\t\t\t\t\tshapeType = this.shapeType;\n\t\t\t\t\n\t\t\t\t// Get X coordinate in pixels\n\t\t\t\tif (origin.x === \"center\") {\n\t\t\t\t\tx = (shapeType === \"rectangular\") ? this.width / 2 : 0;\n\t\t\t\t} else if (origin.x === \"right\") {\n\t\t\t\t\tx = (shapeType === \"rectangular\") ? this.width : this.radius;\n\t\t\t\t} else if (origin.x === \"left\") {\n\t\t\t\t\tx = (shapeType === \"rectangular\") ? 0 : -this.radius;\n\t\t\t\t} else {\n\t\t\t\t\tx = !isNaN(parseFloat(origin.x)) ? parseFloat(origin.x) : 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get Y coordinate in pixels\n\t\t\t\tif (origin.y === \"center\") {\n\t\t\t\t\ty = (shapeType === \"rectangular\") ? this.height / 2 : 0;\n\t\t\t\t} else if (origin.y === \"bottom\") {\n\t\t\t\t\ty = (shapeType === \"rectangular\") ? this.height : this.radius;\n\t\t\t\t} else if (origin.y === \"top\") {\n\t\t\t\t\ty = (shapeType === \"rectangular\") ? 0 : -this.radius;\n\t\t\t\t} else {\n\t\t\t\t\ty = !isNaN(parseFloat(origin.y)) ? parseFloat(origin.y) : 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Return pixel coordinates\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Method for adding a child to the display object\n\t\t\t// Children will transform accordingly when this display object transforms\n\t\t\taddChild: function (childObj, returnIndex) {\n\t\t\t\treturn this.addChildAt(childObj, this.children.length, returnIndex);\n\t\t\t},\n\n\t\t\t// Method for adding a child to the display object at a specific index\n\t\t\t// If index < 0, then the child is added to the beginning of children array\n\t\t\t// If index >= children.length, then the child is added at the end of children array\n\t\t\t// Children will transform accordingly when this display object transforms\n\t\t\taddChildAt: function (childObj, index, returnIndex) {\n\n\t\t\t\t// Check if the child object doesn't already have a parent\n\t\t\t\tif (childObj.parent === undefined) {\n\n\t\t\t\t\tvar realIndex;\n\n\t\t\t\t\t// Add the object as a child\n\t\t\t\t\tif (index >= this.children.length) {\n\t\t\t\t\t\trealIndex = this.children.push(childObj) - 1;\n\t\t\t\t\t} else if (index < 0) {\n\t\t\t\t\t\tthis.children.unshift(childObj);\n\t\t\t\t\t\trealIndex = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.children.splice(index, 0, childObj);\n\t\t\t\t\t\trealIndex = index;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update child\n\t\t\t\t\tchildObj.parent = this;\n\t\t\t\t\tchildObj.x += 0;\n\t\t\t\t\tchildObj.y += 0;\n\n\t\t\t\t\t// Add it to a global list of all objects. Deprecated list, will be removed soon.\n\t\t\t\t\tthis.core.draw.objects.push(childObj);\n\n\t\t\t\t\t// Redraw the canvas if this object is drawn, to show the new child object\n\t\t\t\t\tif (this.drawn) {\n\t\t\t\t\t\tthis.core.draw.redraw();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnIndex) {\n\t\t\t\t\t\treturn realIndex;\n\t\t\t\t\t}\n\t\t\t\t} else if (returnIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Return the object itself if user chose to not get the index in return\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Method for removing a child\n\t\t\tremoveChild: function (childObj, redraw) {\n\t\t\t\tvar index = this.children.indexOf(childObj);\n\t\t\t\tif (~index) {\n\t\t\t\t\tthis.removeChildAt(index, redraw);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for removing a child at a specific index\n\t\t\tremoveChildAt: function (index, redraw) {\n\t\t\t\tif (this.children[index] !== undefined) {\n\t\t\t\t\tthis.children[index].remove(redraw);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for creating a clone of this object\n\t\t\tclone: function (settings) {\n\t\t\t\tsettings = settings || {};\n\t\t\t\tsettings.drawn = false;\n\t\t\t\tvar originalParent = this.parent;\n\t\t\t\tvar newObj = this.core.display[this.type](settings),\n\t\t\t\t\tthis_filtered = {},\n\t\t\t\t\treject = [\"core\", \"events\", \"children\", \"parent\", \"img\", \"image\", \"fill\", \"strokeColor\", \"added\"],\n\t\t\t\t\tabsoluteX = ['abs_x', 'start_x', 'end_x'],\n\t\t\t\t\tabsoluteY = ['abs_y', 'start_y', 'end_y'],\n\t\t\t\t\tloopObject, x, stroke, i, children, child, dX, dY, descriptor;\n\t\t\t\t\n\t\t\t\t// Filter out the setter and getter methods, and also properties listed above\n\t\t\t\tloopObject = function (obj, destination) {\n\t\t\t\t\tfor (x in obj) {\n\t\t\t\t\t\tif (~reject.indexOf(x)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check the descriptor to see if it has no getter method.\n\t\t\t\t\t\t// This uses the getPropertyDescriptor method (planned to arrive in ES6),\n\t\t\t\t\t\t// which is pollyfilled in oCanvas if it's not available.\n\t\t\t\t\t\tdescriptor = Object.getPropertyDescriptor(obj, x);\n\t\t\t\t\t\tif (descriptor && descriptor.get === undefined) {\n\n\t\t\t\t\t\t\t// If the value is an object, we must copy each property of that object.\n\t\t\t\t\t\t\t// This is so that we don't get objects that are shared between two\n\t\t\t\t\t\t\t// display objects.\n\t\t\t\t\t\t\tif (typeof obj[x] === \"object\") {\n\t\t\t\t\t\t\t\tdestination[x] = (obj[x].constructor === Array) ? [] : {};\n\t\t\t\t\t\t\t\tloopObject(obj[x], destination[x]);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar value = obj[x];\n\n\t\t\t\t\t\t\t// If the original object has a parent, we must remove the absolute position\n\t\t\t\t\t\t\t// of the parent to get local positions for the new object. This is because\n\t\t\t\t\t\t\t// the new object will not yet have a parent, so the absolute positions can't\n\t\t\t\t\t\t\t// be based on a parent.\n\t\t\t\t\t\t\tif (originalParent) {\n\t\t\t\t\t\t\t\tif (absoluteX.indexOf(x) > -1) value -= originalParent.abs_x;\n\t\t\t\t\t\t\t\telse if (absoluteY.indexOf(x) > -1) value -= originalParent.abs_y;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdestination[x] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tloopObject(this, this_filtered);\n\t\t\t\t\n\t\t\t\t// Fix gradients and patterns\n\t\t\t\tthis_filtered.fill = this._.fill;\n\t\t\t\tstroke = this.core.style.getStroke(this.stroke);\n\t\t\t\tthis_filtered.strokeColor = stroke.color;\n\n\t\t\t\t// Fix image source (ignored above since it can be set to a DOM node)\n\t\t\t\tif (this.image) {\n\t\t\t\t\tthis_filtered.image = this.image;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Extend the new object with this object's properties and then apply the custom settings\n\t\t\t\tnewObj = oCanvas.extend(newObj, this_filtered, settings);\n\t\t\t\tnewObj.id = ++this.core.lastObjectID;\n\t\t\t\t\n\t\t\t\tif (typeof newObj.init === \"function\") {\n\t\t\t\t\tnewObj.init();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add children to the new clone\n\t\t\t\tchildren = this.children;\n\t\t\t\tif (children.length > 0) {\n\t\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i].clone();\n\t\t\t\t\t\tnewObj.children.push(child);\n\t\t\t\t\t\tchild.parent = newObj;\n\t\t\t\t\t\tif (settings.x) {\n\t\t\t\t\t\t\tdX = Math.abs(children[i].abs_x - this.x);\n\t\t\t\t\t\t\tchild.x = dX;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (settings.y) {\n\t\t\t\t\t\t\tdY = Math.abs(children[i].abs_y - this.y);\n\t\t\t\t\t\t\tchild.y = dY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn newObj;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for checking if the pointer is inside the object\n\t\t\tisPointerInside: function (pointer) {\n\t\t\t\treturn this.core.tools.isPointerInside(this, pointer);\n\t\t\t}\n\t\t};\n\t},\n\t\n\t// Method for registering a custom display object at run time\n\t// It is only attached to the current core instance\n\tregister = function (name, properties, draw, init) {\n\t\tvar display = this,\n\t\t\tcore = this.core,\n\t\t\t\n\t\t\t// The object that will be instantiated\n\t\t\tobj = function (settings, thecore) {\n\t\t\t\n\t\t\t\t// Return an object containing base properties, core access and a draw wrapper\n\t\t\t\t// The object is extended with properties set on register, and settings set on instantiation\n\t\t\t\treturn oCanvas.extend({\n\t\t\t\t\tcore: thecore,\n\t\t\t\t\ttype: name,\n\t\t\t\t\tshapeType: \"rectangular\",\n\t\t\t\t\t\n\t\t\t\t\t// Wrapper for the draw method. This enables the callback to work internally and gives the user\n\t\t\t\t\t// access to the canvas context and the core\n\t\t\t\t\tdraw: function () {\n\t\t\t\t\t\tdraw.call(this, core.canvas, core);\n\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t}, properties, settings);\n\t\t\t};\n\t\t\n\t\t// Add the constructor function to core.display.name\n\t\tthis[name] = function (settings) {\n\t\t\n\t\t\t// Instantiate a new custom object with specified settings\n\t\t\tvar retObj = oCanvas.extend(Object.create(displayObject()), new obj(settings, core));\n\t\t\t\n\t\t\t// Run initialization method if provided\n\t\t\tif (init !== undefined && typeof retObj[init] === \"function\") {\n\t\t\t\tretObj[init]();\n\t\t\t}\n\t\t\t\n\t\t\t// Return the new object\n\t\t\treturn retObj;\n\t\t};\n\t\t\n\t\treturn display;\n\t};\n\t\n\t// Register the module\n\toCanvas.registerModule(\"displayObject\", displayObject);\n\t\n\t// Second namespace where objects gets placed\n\toCanvas.registerModule(\"display\", { wrapper: true, register: register });\n\t\n\t\n\t\n\t// Add method to oCanvas to enable display objects to be added\n\toCanvas.registerDisplayObject = function (name, obj, init) {\n\t\n\t\t// Register the object as a submodule to display\n\t\toCanvas.registerModule(\"display.\"+name, {\n\t\t\n\t\t\t// Method for getting the core instance\n\t\t\tsetCore: function (thecore) {\n\t\t\t\n\t\t\t\t// Method that core.display.objectname will refer to\n\t\t\t\treturn function (settings) {\n\t\t\t\t\n\t\t\t\t\t// Create a new object that inherits from displayObject\n\t\t\t\t\tvar retObj = oCanvas.extend(Object.create(displayObject()), new obj(settings, thecore));\n\t\t\t\t\tretObj.type = name;\n\t\t\t\t\tretObj.id = ++thecore.lastObjectID;\n\t\t\t\t\tthecore.animation.queues.create(retObj, \"default\");\n\t\t\t\t\t\n\t\t\t\t\t// Trigger an init method if specified\n\t\t\t\t\tif (init !== undefined) {\n\t\t\t\t\t\tretObj[init]();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Return the new object\n\t\t\t\t\treturn retObj;\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t};\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobject.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/arc.js":
/*!********************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/arc.js ***!
  \********************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar arc = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\tshapeType: \"radial\",\n\t\t\tradius: 0,\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tdirection: \"clockwise\",\n\t\t\tpieSection: false,\n\t\t\tclipChildren: false,\n\t\t\t\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y;\n\n\t\t\t\t// beginPath and closePath must be outside if statement because the clipChildren feature (a radius of 0 must hide all children)\n\t\t\t\tcanvas.beginPath();\n\t\t\t\t\n\t\t\t\t// Don't draw if the radius is 0 or less (won't be visible anyway)\n\t\t\t\tif (this.radius > 0 && this.start !== this.end) {\n\t\t\t\t\n\t\t\t\t\t// Draw the arc\n\t\t\t\t\tif (this.pieSection) {\n\t\t\t\t\t\tcanvas.moveTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.arc(x, y, this.radius, this.start * Math.PI / 180, this.end * Math.PI / 180, (this.direction === \"anticlockwise\"));\n\t\t\t\t\t\n\t\t\t\t\t// Do fill\n\t\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\t\tcanvas.fill();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Do stroke\n\t\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\t\t\tcanvas.stroke();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tcanvas.closePath();\n\n\t\t\t\t// Do clip\n\t\t\t\tif(this.clipChildren) {\n\t\t\t\t\tcanvas.clip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"arc\", arc);\n\t\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/arc.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/ellipse.js":
/*!************************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/ellipse.js ***!
  \************************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar ellipse = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\tshapeType: \"radial\",\n\t\t\tclipChildren: false,\n\t\t\t\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\tradius_x: 0,\n\t\t\t\tradius_y: 0\n\t\t\t}),\n\t\t\t\n\t\t\tset radius (value) {\n\t\t\t\tthis._.radius_x = value;\n\t\t\t\tthis._.radius_y = value;\n\t\t\t},\n\t\t\t\n\t\t\tset radius_x (value) {\n\t\t\t\tthis._.radius_x = value;\n\t\t\t},\n\t\t\t\n\t\t\tset radius_y (value) {\n\t\t\t\tthis._.radius_y = value;\n\t\t\t},\n\t\t\t\n\t\t\tget radius () {\n\t\t\t\treturn this._.radius_x;\n\t\t\t},\n\t\t\t\n\t\t\tget radius_x () {\n\t\t\t\treturn this._.radius_x;\n\t\t\t},\n\t\t\t\n\t\t\tget radius_y () {\n\t\t\t\treturn this._.radius_y;\n\t\t\t},\n\n\t\t\tgetOrigin: function () {\n\t\t\t\tvar x = 0;\n\t\t\t\tvar y = 0;\n\t\t\t\tvar origin = this.origin;\n\n\t\t\t\tif (this.origin.x === \"right\") {\n\t\t\t\t\tx = this.radius_x;\n\t\t\t\t} else if (this.origin.x === \"left\") {\n\t\t\t\t\tx = -this.radius_x;\n\t\t\t\t} else {\n\t\t\t\t\tx = !isNaN(parseFloat(this.origin.x)) ? parseFloat(this.origin.x) : 0;\n\t\t\t\t}\n\n\t\t\t\tif (this.origin.y === \"bottom\") {\n\t\t\t\t\ty = this.radius_y;\n\t\t\t\t} else if (this.origin.y === \"top\") {\n\t\t\t\t\ty = -this.radius_y;\n\t\t\t\t} else {\n\t\t\t\t\ty = !isNaN(parseFloat(this.origin.y)) ? parseFloat(this.origin.y) : 0;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y;\n\t\t\t\t\n\t\t\t\tcanvas.beginPath();\n\t\t\t\t\n\t\t\t\t// Draw a perfect circle with the arc method if both radii are the same\n\t\t\t\tif (this.radius_x === this.radius_y) {\n\t\t\t\t\tcanvas.arc(x, y, this.radius_x, 0, Math.PI * 2, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Draw an ellipse if the radii are not the same\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\t// Calculate values for the ellipse\n\t\t\t\t\tvar EllipseToBezierConstant = 0.276142374915397,\n\t\t\t\t\t\to = {x: this.radius_x * 2 * EllipseToBezierConstant, y: this.radius_y * 2 * EllipseToBezierConstant};\n\t\t\t\t\t\n\t\t\t\t\t// Draw the curves that will form the ellipse\n\t\t\t\t\tcanvas.moveTo(x - this.radius_x, y);\n\t\t\t\t\tcanvas.bezierCurveTo(x - this.radius_x, y - o.y, x - o.x, y - this.radius_y, x, y - this.radius_y);\n\t\t\t\t\tcanvas.bezierCurveTo(x + o.x, y - this.radius_y, x + this.radius_x, y - o.y, x + this.radius_x, y);\n\t\t\t\t\tcanvas.bezierCurveTo(x + this.radius_x, y + o.y, x + o.x, y + this.radius_y, x, y + this.radius_y);\n\t\t\t\t\tcanvas.bezierCurveTo(x - o.x, y + this.radius_y, x - this.radius_x, y + o.y, x - this.radius_x, y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Do fill\n\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\tcanvas.fill();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Do stroke\n\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\t\tcanvas.stroke();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcanvas.closePath();\n\n\t\t\t\t// Do clip\n\t\t\t\tif(this.clipChildren) {\n\t\t\t\t\tcanvas.clip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"ellipse\", ellipse);\n\t\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/ellipse.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/image.js":
/*!**********************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/image.js ***!
  \**********************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar image = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\thasBeenDrawn: false\n\t\t\t}),\n\t\t\t\n\t\t\tshapeType: \"rectangular\",\n\t\t\tloaded: false,\n\t\t\tfirstDrawn: false,\n\t\t\ttile: false,\n\t\t\ttile_width: 0,\n\t\t\ttile_height: 0,\n\t\t\ttile_spacing_x: 0,\n\t\t\ttile_spacing_y: 0,\n\t\t\tclipChildren: false,\n\t\t\t\n\t\t\t// Init method for loading the image resource\n\t\t\tinit: function () {\n\t\t\t\tvar _this = this,\n\t\t\t\t\tsource;\n\n\t\t\t\t// Abort initialization of the image if there is no image specified\n\t\t\t\tif (this.image === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar isImageElement = this.image.nodeName && this.image.nodeName.toLowerCase() === \"img\";\n\t\t\t\tthis.img = isImageElement ? this.image : new Image();\n\t\t\t\t\n\t\t\t\t// Get dimensions when the image is loaded. Also, remove the temp img from DOM\n\t\t\t\tvar onload = function () {\n\t\t\t\t\t_this.loaded = true;\n\t\t\t\t\t\n\t\t\t\t\t// Set dimensions proportionally (if only one is specified, calculate the other)\n\t\t\t\t\tif (_this.width !== 0) {\n\t\t\t\t\t\tif (_this.height === 0) {\n\t\t\t\t\t\t\t_this.height = _this.width / (this.width / this.height);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this.width = this.width;\n\t\t\t\t\t}\n\t\t\t\t\tif (_this.height !== 0) {\n\t\t\t\t\t\tif (_this.width === 0) {\n\t\t\t\t\t\t\t_this.width = _this.height / (this.height / this.width);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this.height = this.height;\n\t\t\t\t\t}\n\t\t\t\t\t_this.tile_width = (_this.tile_width === 0) ? _this.width : _this.tile_width;\n\t\t\t\t\t_this.tile_height = (_this.tile_height === 0) ? _this.height : _this.tile_height;\n\t\t\t\t\tif (_this._.hasBeenDrawn) _this.core.redraw();\n\t\t\t\t};\n\n\t\t\t\tif (isImageElement && this.img.complete) {\n\t\t\t\t\tonload.call(this.img);\n\t\t\t\t} else {\n\t\t\t\t\tthis.img.addEventListener(\"load\", onload);\n\n\t\t\t\t\tif (!isImageElement) {\n\t\t\t\t\t\tthis.img.src = this.image;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method that draws the image to the canvas once it's loaded\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\t_this = this,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y,\n\t\t\t\t\twidth, height;\n\t\t\t\t\n\t\t\t\t// If the image has finished loading, go on and draw\n\t\t\t\tif (this.loaded && this.core.draw.objects[this.zIndex] !== undefined && this.img.width > 0 && this.img.height > 0) {\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\twidth = (this.width === 0) ? this.img.width : this.width;\n\t\t\t\t\theight = (this.height === 0) ? this.img.height : this.height;\n\t\t\t\t\n\t\t\t\t\tif (this.tile) {\n\t\t\t\t\t\n\t\t\t\t\t\tvar num_x = Math.ceil(width / this.tile_width),\n\t\t\t\t\t\t\tnum_y = Math.ceil(height / this.tile_height),\n\t\t\t\t\t\t\ttile_x, tile_y;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcanvas.save();\n\t\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Create clipping path for the rectangle that the tiled images will be drawn inside\n\t\t\t\t\t\tcanvas.moveTo(x, y);\n\t\t\t\t\t\tcanvas.lineTo(x + width, y);\n\t\t\t\t\t\tcanvas.lineTo(x + width, y + height);\n\t\t\t\t\t\tcanvas.lineTo(x, y + height);\n\t\t\t\t\t\tcanvas.lineTo(x, y);\n\t\t\t\t\t\tcanvas.clip();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Draw all the tiled images\n\t\t\t\t\t\tfor (tile_y = 0; tile_y < num_y; tile_y++) {\n\t\t\t\t\t\t\tfor (tile_x = 0; tile_x < num_x; tile_x++) {\n\t\t\t\t\t\t\t\tcanvas.drawImage(this.img, x + tile_x * (this.tile_width + this.tile_spacing_x), y + tile_y * (this.tile_height + this.tile_spacing_y), this.tile_width, this.tile_height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcanvas.closePath();\n\t\t\t\t\t\tcanvas.restore();\n\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t\t// Draw the image to the canvas\n\t\t\t\t\t\tcanvas.drawImage(this.img, x, y, width, height);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Do color if stroke width is specified\n\t\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\t\t\tcanvas.strokeRect(x, y, width, height);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Clear the timer if this is the first time it is drawn\n\t\t\t\t\tif (this.firstDrawn === false) {\n\t\t\t\t\t\tthis.firstDrawn = true;\n\t\t\t\t\t\tclearTimeout(this.loadtimer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If the image hasn't finished loading, set a timer and try again\n\t\t\t\telse {\n\t\t\t\t\tclearTimeout(this.loadtimer);\n\t\t\t\t\tthis.loadtimer = setTimeout(function () {\n\t\t\t\t\t\t_this.draw();\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\n\t\t\t\t// Do clip\n\t\t\t\tif(this.clipChildren) {\n\n\t\t\t\t\t// draw the clip region (the square area around the image)\n\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\tcanvas.rect(x, y, width, height);\n\t\t\t\t\tcanvas.closePath();\n\n\t\t\t\t\tcanvas.clip();\n\n\t\t\t\t}\n\n\t\t\t\tthis._.hasBeenDrawn = true;\n\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"image\", image, \"init\");\n\t\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/image.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/line.js":
/*!*********************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/line.js ***!
  \*********************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar line = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\tshapeType: \"radial\",\n\t\t\t\n\t\t\t// Properties\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\tstart_x: 0,\n\t\t\t\tstart_y: 0,\n\t\t\t\tend_x: 0,\n\t\t\t\tend_y: 0,\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tabs_x: 0,\n\t\t\t\tabs_y: 0\n\t\t\t}),\n\t\t\tchildren: [],\n\t\t\t\n\t\t\t// Getters and setters\n\t\t\tset start (values) {\n\t\t\t\tthis._.start_x = values.x + (this.parent && !this.parent.isCore ? this.parent._.abs_x : 0);\n\t\t\t\tthis._.start_y = values.y + (this.parent && !this.parent.isCore ? this.parent._.abs_y : 0);\n\t\t\t\tthis.setPosition();\n\t\t\t},\n\t\t\tset end (values) {\n\t\t\t\tthis._.end_x = values.x + (this.parent && !this.parent.isCore ? this.parent._.abs_x : 0);\n\t\t\t\tthis._.end_y = values.y + (this.parent && !this.parent.isCore ? this.parent._.abs_y : 0);\n\t\t\t\tthis.setPosition();\n\t\t\t},\n\t\t\tget start () {\n\t\t\t\tvar offset = { x: 0, y: 0 };\n\t\t\t\tif (this.parent && !this.parent.isCore) {\n\t\t\t\t\toffset.x = this.parent._.abs_x;\n\t\t\t\t\toffset.y = this.parent._.abs_y;\n\t\t\t\t}\n\t\t\t\tvar self = this;\n\t\t\t\treturn {\n\t\t\t\t\tget x () { return self._.start_x - offset.x; },\n\t\t\t\t\tget y () { return self._.start_y - offset.y; },\n\t\t\t\t\tset x (value) {\n\t\t\t\t\t\tself._.start_x = value + (self.parent && !self.parent.isCore ? self.parent._.abs_x : 0);\n\t\t\t\t\t\tself.setPosition();\n\t\t\t\t\t},\n\t\t\t\t\tset y (value) {\n\t\t\t\t\t\tself._.start_y = value + (self.parent && !self.parent.isCore ? self.parent._.abs_y : 0);\n\t\t\t\t\t\tself.setPosition();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\tget end () {\n\t\t\t\tvar offset = { x: 0, y: 0 };\n\t\t\t\tif (this.parent && !this.parent.isCore) {\n\t\t\t\t\toffset.x = this.parent._.abs_x;\n\t\t\t\t\toffset.y = this.parent._.abs_y;\n\t\t\t\t}\n\t\t\t\tvar self = this;\n\t\t\t\treturn {\n\t\t\t\t\tget x () { return self._.end_x - offset.x; },\n\t\t\t\t\tget y () { return self._.end_y - offset.y; },\n\t\t\t\t\tset x (value) {\n\t\t\t\t\t\tself._.end_x = value + (self.parent && !self.parent.isCore ? self.parent._.abs_x : 0);\n\t\t\t\t\t\tself.setPosition();\n\t\t\t\t\t},\n\t\t\t\t\tset y (value) {\n\t\t\t\t\t\tself._.end_y = value + (self.parent && !self.parent.isCore ? self.parent._.abs_y : 0);\n\t\t\t\t\t\tself.setPosition();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Overwrite the setters that displayObject provides, to enable start/end coordinates to affect the position\n\t\t\tset x (value) {\n\t\t\t\tvar diff, offsetX, objects, l, i;\n\n\t\t\t\t// Get delta length\n\t\t\t\tdiff = this._.end_x - this._.start_x;\n\n\t\t\t\t// Get parent offset\n\t\t\t\toffsetX = this.parent && !this.parent.isCore ? this.parent._.abs_x : 0;\n\t\t\t\t\n\t\t\t\t// Assign new x positions for the object\n\t\t\t\tthis._.x = value;\n\t\t\t\tthis._.abs_x = value + offsetX;\n\t\t\t\t\n\t\t\t\t// Assign new x positions for start and end points\n\t\t\t\tthis._.start_x = value - (diff / 2) + offsetX;\n\t\t\t\tthis._.end_x = value + (diff / 2) + offsetX;\n\t\t\t\t\n\t\t\t\t// Update children\n\t\t\t\tobjects = this.children;\n\t\t\t\tl = objects.length;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tobjects[i]._.abs_x = this.abs_x + objects[i].x;\n\t\t\t\t\tobjects[i].x += 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset y (value) {\n\t\t\t\tvar diff, offsetY, objects, l, i;\n\n\t\t\t\t// Get delta length\n\t\t\t\tdiff = this._.end_y - this._.start_y,\n\t\t\t\t\n\t\t\t\t// Get parent offset\n\t\t\t\toffsetY = this.parent && !this.parent.isCore ? this.parent._.abs_y : 0;\n\t\t\t\t\n\t\t\t\t// Assign new y positions for the object\n\t\t\t\tthis._.y = value;\n\t\t\t\tthis._.abs_y = value + offsetY;\n\t\t\t\t\n\t\t\t\t// Assign new y positions for start and end points\n\t\t\t\tthis._.start_y = value - (diff / 2) + offsetY;\n\t\t\t\tthis._.end_y = value + (diff / 2) + offsetY;\n\t\t\t\t\n\t\t\t\t// Update children\n\t\t\t\tobjects = this.children;\n\t\t\t\tl = objects.length;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tobjects[i]._.abs_y = this.abs_y - objects[i].y;\n\t\t\t\t\tobjects[i].y += 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget x () {\n\t\t\t\treturn this._.x;\n\t\t\t},\n\t\t\tget y () {\n\t\t\t\treturn this._.y;\n\t\t\t},\n\t\t\t\n\t\t\tset length (value) {\n\t\t\t\tvar dX, dY, length, angle;\n\t\t\t\t\n\t\t\t\t// Find current length and angle\n\t\t\t\tdX = Math.abs(this._.end_x - this._.start_x);\n\t\t\t\tdY = Math.abs(this._.end_y - this._.start_y);\n\t\t\t\tlength = Math.sqrt(dX * dX + dY * dY);\n\t\t\t\tangle = Math.asin(dX / length);\n\t\t\t\t\n\t\t\t\t// Calculate new values\n\t\t\t\tdX = Math.sin(angle) * value;\n\t\t\t\tdY = Math.cos(angle) * value;\n\t\t\t\tthis._.end_x = this._.start_x + dX;\n\t\t\t\tthis._.end_y = this._.start_y + dY;\n\t\t\t\tthis.x += 0;\n\t\t\t\tthis.y += 0;\n\n\t\t\t\tthis.setPosition();\n\t\t\t},\n\t\t\tget length () {\n\t\t\t\tvar dX, dY, length;\n\t\t\t\t\n\t\t\t\tdX = Math.abs(this._.end_x - this._.start_x);\n\t\t\t\tdY = Math.abs(this._.end_y - this._.start_y);\n\t\t\t\tlength = Math.sqrt(dX * dX + dY * dY);\n\t\t\t\t\n\t\t\t\treturn length;\n\t\t\t},\n\t\t\t\n\t\t\tset radius (value) {\n\t\t\t\tthis.length = value * 2;\n\t\t\t},\n\t\t\tget radius () {\n\t\t\t\treturn this.length / 2;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for setting x/y coordinates (which will set abs_x/abs_y as specified by displayObject)\n\t\t\tsetPosition: function () {\n\t\t\t\tvar offset = { x: 0, y: 0 };\n\t\t\t\tif (this.parent && !this.parent.isCore) {\n\t\t\t\t\toffset.x = this.parent._.abs_x;\n\t\t\t\t\toffset.y = this.parent._.abs_y;\n\t\t\t\t}\n\t\t\t\tthis.x = this._.start_x - offset.x + (this._.end_x - this._.start_x) / 2;\n\t\t\t\tthis.y = this._.start_y - offset.y + (this._.end_y - this._.start_y) / 2;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for initializing the dimensions\n\t\t\tinit: function () {\n\t\t\t\tthis.initialized = true;\n\t\t\t\tthis.setPosition();\n\t\t\t},\n\t\t\t\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\ttranslation = this.core.draw.translation;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\tcanvas.beginPath();\n\t\t\t\tcanvas.moveTo(this._.start_x - translation.x - origin.x, this._.start_y - translation.y - origin.y);\n\t\t\t\tcanvas.lineTo(this._.end_x - translation.x - origin.x, this._.end_y - translation.y - origin.y);\n\t\t\t\tcanvas.stroke();\n\t\t\t\tcanvas.closePath();\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"line\", line, \"init\");\n\t\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/line.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/polygon.js":
/*!************************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/polygon.js ***!
  \************************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar polygon = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\tshapeType: \"radial\",\n\t\t\tsides: 3,\n\t\t\tclipChildren: false,\n\t\t\t\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\tradius: 0,\n\t\t\t\tside: 0\n\t\t\t}),\n\t\t\t\n\t\t\tset radius (value) {\n\t\t\t\tthis._.radius = value;\n\t\t\t\tthis._.side = 2 * this._.radius * Math.sin(Math.PI / this.sides);\n\t\t\t},\n\t\t\t\n\t\t\tset side (value) {\n\t\t\t\tthis._.side = value;\n\t\t\t\tthis._.radius = (this._.side / 2) / Math.sin(Math.PI / this.sides);\n\t\t\t},\n\t\t\t\n\t\t\tget radius () {\n\t\t\t\treturn this._.radius;\n\t\t\t},\n\t\t\t\n\t\t\tget side () {\n\t\t\t\treturn this._.side;\n\t\t\t},\n\t\t\t\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y,\n\t\t\t\t\tfirstPoint = { x: 0, y: 0 },\n\t\t\t\t\tsides = this.sides,\n\t\t\t\t\tradius = this.radius,\n\t\t\t\t\txPos, yPos, i;\n\t\t\t\t\n\t\t\t\tcanvas.beginPath();\n\t\t\t\t\n\t\t\t\tfor (i = 0; i <= sides; i++) {\n\t\t\t\t\txPos = x + radius * Math.cos(i * 2 * Math.PI / sides);\n\t\t\t\t\tyPos = y + radius * Math.sin(i * 2 * Math.PI / sides);\n\t\t\t\t\t\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcanvas.moveTo(xPos, yPos);\n\t\t\t\t\t\tfirstPoint = { x: xPos, y: yPos };\n\t\t\t\t\t} else\n\t\t\t\t\tif (i == sides) {\n\t\t\t\t\t\tcanvas.lineTo(firstPoint.x, firstPoint.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas.lineTo(xPos, yPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcanvas.closePath();\n\t\t\t\t\n\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\tcanvas.fill();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\t\tcanvas.stroke();\n\t\t\t\t}\n\n\t\t\t\t// Do clip\n\t\t\t\tif(this.clipChildren) {\n\t\t\t\t\tcanvas.clip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"polygon\", polygon);\n\t\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/polygon.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/rectangle.js":
/*!**************************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/rectangle.js ***!
  \**************************************************************/
/***/ (() => {

eval("(function (oCanvas, window, document, undefined) {\n\n\t// Define the class\n\tvar rectangle = function (settings, thecore) {\n\n\t\tfunction checkBounds(borderRadiusValue, maxValue) {\n\t\t\treturn Math.max(Math.min(borderRadiusValue, maxValue), 0);\n\t\t}\n\n\t\tfunction normalizeCornerBorderRadius(cornerBorderRadius, generalBorderRadius, maxValue) {\n\n\t\t\tif (cornerBorderRadius !== undefined) {\n\t\t\t\treturn checkBounds(cornerBorderRadius, maxValue);\n\t\t\t}\n\n\t\t\tif (generalBorderRadius !== undefined) {\n\t\t\t\treturn checkBounds(generalBorderRadius, maxValue);\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tfunction normalizeBorderRadius(borderRadius, borderTopLeftRadius, borderTopRightRadius, borderBottomLeftRadius, borderBottomRightRadius, maxValue) {\n\n\t\t\treturn {\n\t\t\t\ttopLeft: normalizeCornerBorderRadius(borderTopLeftRadius, borderRadius, maxValue),\n\t\t\t\ttopRight: normalizeCornerBorderRadius(borderTopRightRadius, borderRadius, maxValue),\n\t\t\t\tbottomLeft: normalizeCornerBorderRadius(borderBottomLeftRadius, borderRadius, maxValue),\n\t\t\t\tbottomRight: normalizeCornerBorderRadius(borderBottomRightRadius, borderRadius, maxValue)\n\t\t\t};\n\n\t\t}\n\n\t\tfunction addAmountToBorderRadius(borderRadius, amount) {\n\t\t\tif (amount > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t// When there is no borderRadius (=== 0), keep it as 0\n\t\t\t\t\ttopLeft: borderRadius.topLeft === 0 ? 0 : borderRadius.topLeft + amount,\n\t\t\t\t\ttopRight: borderRadius.topRight === 0 ? 0 : borderRadius.topRight + amount,\n\t\t\t\t\tbottomLeft: borderRadius.bottomLeft === 0 ? 0 : borderRadius.bottomLeft + amount,\n\t\t\t\t\tbottomRight: borderRadius.bottomRight === 0 ? 0 : borderRadius.bottomRight + amount\n\t\t\t\t};\n\t\t\t} else if (amount < 0) {\n\t\t\t\treturn {\n\t\t\t\t\t// Never least than 0\n\t\t\t\t\ttopLeft: Math.max(borderRadius.topLeft + amount, 0),\n\t\t\t\t\ttopRight: Math.max(borderRadius.topRight + amount, 0),\n\t\t\t\t\tbottomLeft: Math.max(borderRadius.bottomLeft + amount, 0),\n\t\t\t\t\tbottomRight: Math.max(borderRadius.bottomRight + amount, 0)\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn borderRadius;\n\t\t\t}\n\t\t}\n\n\t\tfunction hasBorderRadius(borderRadius) {\n\t\t\treturn borderRadius.topLeft > 0\n\t\t\t\t|| borderRadius.topRight > 0\n\t\t\t\t|| borderRadius.bottomLeft > 0\n\t\t\t\t|| borderRadius.bottomRight > 0;\n\t\t}\n\n\t\tfunction drawBorderRadiusRect(canvas, x, y, width, height, borderRadius, counterclockwise) {\n\n\t\t\tvar endX = x + width,\n\t\t\t\tendY = y + height;\n\n\t\t\tif (counterclockwise) {\n\n\t\t\t\tcanvas.moveTo(endX - borderRadius.topRight, y);\n\n\t\t\t\t// top line and top-left border\n\t\t\t\tcanvas.arcTo(x, y, x, y + borderRadius.topLeft, borderRadius.topLeft);\n\n\t\t\t\t// left line and bottom-left border\n\t\t\t\tcanvas.arcTo(x, endY, x + borderRadius.bottomLeft, endY, borderRadius.bottomLeft);\n\n\t\t\t\t// bottom line and bottom-right border\n\t\t\t\tcanvas.arcTo(endX, endY, endX, endY - borderRadius.bottomRight, borderRadius.bottomRight);\n\n\t\t\t\t// right line and top-right border\n\t\t\t\tcanvas.arcTo(endX, y, endX - borderRadius.topRight, y, borderRadius.topRight);\n\n\t\t\t} else {\n\n\t\t\t\tcanvas.moveTo(x + borderRadius.topLeft, y);\n\n\t\t\t\t// top line and top-right border\n\t\t\t\tcanvas.arcTo(endX, y, endX, y + borderRadius.topRight, borderRadius.topRight);\n\n\t\t\t\t// right line and bottom-right border\n\t\t\t\tcanvas.arcTo(endX, endY, endX - borderRadius.bottomRight, endY, borderRadius.bottomRight);\n\n\t\t\t\t// bottom line and bottom-left border\n\t\t\t\tcanvas.arcTo(x, endY, x, endY - borderRadius.bottomLeft, borderRadius.bottomLeft);\n\n\t\t\t\t// left line and top-left border\n\t\t\t\tcanvas.arcTo(x, y, x + borderRadius.topLeft, y, borderRadius.topLeft);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\n\t\t\tshapeType: \"rectangular\",\n\t\t\tclipChildren: false,\n\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\tborderTopLeftRadius: 0,\n\t\t\t\tborderTopRightRadius: 0,\n\t\t\t\tborderBottomRightRadius: 0,\n\t\t\t\tborderBottomLeftRadius: 0,\n\t\t\t\tborderRadius: 0,\n\t\t\t}),\n\n\t\t\tset borderTopLeftRadius (value) {\n\t\t\t\tthis._.borderTopLeftRadius = parseFloat(value, 10);\n\t\t\t},\n\n\t\t\tget borderTopLeftRadius () {\n\t\t\t\treturn this._.borderTopLeftRadius;\n\t\t\t},\n\n\t\t\tset borderTopRightRadius (value) {\n\t\t\t\tthis._.borderTopRightRadius = parseFloat(value, 10);\n\t\t\t},\n\n\t\t\tget borderTopRightRadius () {\n\t\t\t\treturn this._.borderTopRightRadius;\n\t\t\t},\n\n\t\t\tset borderBottomRightRadius (value) {\n\t\t\t\tthis._.borderBottomRightRadius = parseFloat(value, 10);\n\t\t\t},\n\n\t\t\tget borderBottomRightRadius () {\n\t\t\t\treturn this._.borderBottomRightRadius;\n\t\t\t},\n\n\t\t\tset borderBottomLeftRadius (value) {\n\t\t\t\tthis._.borderBottomLeftRadius = parseFloat(value, 10);\n\t\t\t},\n\n\t\t\tget borderBottomLeftRadius () {\n\t\t\t\treturn this._.borderBottomLeftRadius;\n\t\t\t},\n\n\t\t\tset borderRadius (value) {\n\t\t\t\tvar floatValue = parseFloat(value, 10);\n\t\t\t\tthis._.borderRadius = floatValue;\n\t\t\t\tthis._.borderTopLeftRadius = floatValue;\n\t\t\t\tthis._.borderTopRightRadius = floatValue;\n\t\t\t\tthis._.borderBottomRightRadius = floatValue;\n\t\t\t\tthis._.borderBottomLeftRadius = floatValue;\n\t\t\t},\n\n\t\t\tget borderRadius () {\n\t\t\t\tvar a = this._.borderTopLeftRadius;\n\t\t\t\tvar b = this._.borderTopRightRadius;\n\t\t\t\tvar c = this._.borderBottomRightRadius;\n\t\t\t\tvar d = this._.borderBottomLeftRadius;\n\t\t\t\tif (a === b && b === c && c === d) {\n\t\t\t\t\tthis._.borderRadius = a;\n\t\t\t\t}\n\t\t\t\treturn this._.borderRadius;\n\t\t\t},\n\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y;\n\n\t\t\t\tvar borderRadius = normalizeBorderRadius(\n\t\t\t\t\tthis.borderRadius,\n\t\t\t\t\tthis.borderTopLeftRadius,\n\t\t\t\t\tthis.borderTopRightRadius,\n\t\t\t\t\tthis.borderBottomLeftRadius,\n\t\t\t\t\tthis.borderBottomRightRadius,\n\t\t\t\t\tMath.min(this.width, this.height) / 2\n\t\t\t\t);\n\n\t\t\t\tif (!hasBorderRadius(borderRadius)) {\n\n\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\tcanvas.rect(x, y, this.width, this.height);\n\t\t\t\t\tcanvas.closePath();\n\n\t\t\t\t\t// Do fill if a color is specified\n\t\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\t\tcanvas.fill();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do color if stroke width is specified\n\t\t\t\t\tif (this.strokeWidth > 0) {\n\n\t\t\t\t\t\t// Set styles\n\t\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\n\t\t\t\t\t\t// Set stroke outside the box\n\t\t\t\t\t\tif (this.strokePosition === \"outside\") {\n\t\t\t\t\t\t\tcanvas.strokeRect(x - this.strokeWidth / 2, y - this.strokeWidth / 2, this.width + this.strokeWidth, this.height + this.strokeWidth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set stroke on the edge of the box (half of the stroke outside, half inside)\n\t\t\t\t\t\telse if (this.strokePosition === \"center\") {\n\t\t\t\t\t\t\tcanvas.strokeRect(x, y, this.width, this.height);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set stroke on the inside of the box\n\t\t\t\t\t\telse if (this.strokePosition === \"inside\") {\n\t\t\t\t\t\t\tcanvas.strokeRect(x + this.strokeWidth / 2, y + this.strokeWidth / 2, this.width - this.strokeWidth, this.height - this.strokeWidth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do clip\n\t\t\t\t\tif (this.clipChildren) {\n\t\t\t\t\t\tcanvas.clip();\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\tdrawBorderRadiusRect(canvas, x, y, this.width, this.height, borderRadius);\n\t\t\t\t\tcanvas.closePath();\n\n\t\t\t\t\t// Do fill if a color is specified\n\t\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\t\tcanvas.fill();\n\t\t\t\t\t}\n\n\t\t\t\t\tvar strokeSimulatedUsingPath = false;\n\n\t\t\t\t\t// Do color if stroke width is specified\n\t\t\t\t\tif (this.strokeWidth > 0) {\n\n\t\t\t\t\t\tif (this.strokePosition === 'center') {\n\n\t\t\t\t\t\t\t// Set styles\n\t\t\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\n\t\t\t\t\t\t\tcanvas.stroke();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Simulate stroke using a path\n\n\t\t\t\t\t\t\tcanvas.beginPath();\n\n\t\t\t\t\t\t\tif (this.strokePosition === 'inside') {\n\t\t\t\t\t\t\t\tdrawBorderRadiusRect(canvas, x, y, this.width, this.height, borderRadius);\n\t\t\t\t\t\t\t\tdrawBorderRadiusRect(canvas, x + this.strokeWidth, y + this.strokeWidth, this.width - this.strokeWidth * 2, this.height - this.strokeWidth * 2, addAmountToBorderRadius(borderRadius, -this.strokeWidth), true);\n\t\t\t\t\t\t\t} else if (this.strokePosition === 'outside') {\n\t\t\t\t\t\t\t\tdrawBorderRadiusRect(canvas, x - this.strokeWidth, y - this.strokeWidth, this.width + this.strokeWidth * 2, this.height + this.strokeWidth * 2, addAmountToBorderRadius(borderRadius, this.strokeWidth), true);\n\t\t\t\t\t\t\t\tdrawBorderRadiusRect(canvas, x, y, this.width, this.height, borderRadius);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcanvas.closePath();\n\n\t\t\t\t\t\t\tcanvas.fillStyle = this.strokeColor;\n\t\t\t\t\t\t\tcanvas.fill();\n\n\t\t\t\t\t\t\tstrokeSimulatedUsingPath = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do clip\n\t\t\t\t\tif (this.clipChildren) {\n\n\t\t\t\t\t\tif (strokeSimulatedUsingPath) {\n\t\t\t\t\t\t\t// If a stroke was drawn using a path, we have to draw another path\n\t\t\t\t\t\t\t// with the same size as the fill path in order to clip children\n\t\t\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\t\t\tdrawBorderRadiusRect(canvas, x, y, this.width, this.height, borderRadius);\n\t\t\t\t\t\t\tcanvas.closePath();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcanvas.clip();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t}, settings);\n\t};\n\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"rectangle\", rectangle);\n\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/rectangle.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/sprite.js":
/*!***********************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/sprite.js ***!
  \***********************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar sprite = function (settings, thecore) {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\t// Set properties\n\t\t\tshapeType: \"rectangular\",\n\t\t\tloaded: false,\n\t\t\tfirstDrawn: false,\n\t\t\tframes: [],\n\t\t\tduration: 0,\n\t\t\tframe: 1,\n\t\t\tgenerate: false,\n\t\t\tnumFrames: 0,\n\t\t\toffset_x: 0,\n\t\t\toffset_y: 0,\n\t\t\tdirection: \"x\",\n\t\t\trunning: false,\n\t\t\tactive: false,\n\t\t\tloop: true,\n\t\t\tclipChildren: false,\n\t\t\t\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\tautostart: false,\n\t\t\t\thasBeenDrawn: false\n\t\t\t}),\n\t\t\t\n\t\t\tset autostart (value) {\n\t\t\t\tthis.active = value;\n\t\t\t\tthis._.autostart = value;\n\t\t\t},\n\t\t\t\n\t\t\tget autostart () {\n\t\t\t\treturn this._.autostart;\n\t\t\t},\n\t\t\t\n\t\t\t// Init method for loading the image resource\n\t\t\tinit: function () {\n\t\t\t\tif (this.image === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar _this = this;\n\n\t\t\t\tvar isImageElement = this.image.nodeName && this.image.nodeName.toLowerCase() === \"img\";\n\t\t\t\tthis.img = isImageElement ? this.image : new Image();\n\t\t\t\t\n\t\t\t\t// Get dimensions when the image is loaded. Also, remove the temp img from DOM\n\t\t\t\tvar onload = function () {\n\t\t\t\t\n\t\t\t\t\t// Set the full source image dimensions\n\t\t\t\t\t_this.full_width = this.width;\n\t\t\t\t\t_this.full_height = this.height;\n\n\t\t\t\t\t// If automatic generation is specified\n\t\t\t\t\tif (_this.generate) {\n\t\t\t\t\t\tvar dir, length_full, length_cropped, num_frames, i;\n\t\t\t\t\t\n\t\t\t\t\t\t// Get frame data\n\t\t\t\t\t\tdir = _this.direction;\n\t\t\t\t\t\tlength_full = (dir === \"y\") ? _this.full_height : _this.full_width;\n\t\t\t\t\t\tlength_cropped = (dir === \"y\") ? _this.height : _this.width;\n\n\t\t\t\t\t\tif (_this.numFrames > 0) {\n\t\t\t\t\t\t\tnum_frames = _this.numFrames;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnum_frames = length_full / length_cropped;\n\t\t\t\t\t\t\t_this.numFrames = num_frames;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Create frames based on the specified width, height, direction, offset and duration\n\t\t\t\t\t\t_this.frames = [];\n\t\t\t\t\t\tfor (i = 0; i < num_frames; i++) {\n\t\t\t\t\t\t\t_this.frames.push({\n\t\t\t\t\t\t\t\tx: _this.offset_x + (i * (dir === \"x\" ? _this.width : 0)),\n\t\t\t\t\t\t\t\ty: _this.offset_y + (i * (dir === \"y\" ? _this.height : 0)),\n\t\t\t\t\t\t\t\td: _this.duration\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_this.loaded = true;\n\t\t\t\t\tif (_this._.hasBeenDrawn) _this.core.redraw();\n\t\t\t\t};\n\n\t\t\t\tif (isImageElement && this.img.complete) {\n\t\t\t\t\tonload.call(this.img);\n\t\t\t\t} else {\n\t\t\t\t\tthis.img.addEventListener(\"load\", onload);\n\n\t\t\t\t\tif (!isImageElement) {\n\t\t\t\t\t\tthis.img.src = this.image;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\tdraw: function () {\n\t\t\t\tvar _this = this,\n\t\t\t\t\tcanvas = this.core.canvas,\n\t\t\t\t\torigin = this.getOrigin(),\n\t\t\t\t\tx = this.abs_x - origin.x,\n\t\t\t\t\ty = this.abs_y - origin.y,\n\t\t\t\t\tframe;\n\n\t\t\t\t// If the image has not been loaded or the sprite has no frames, the frame size must be 0 (for clipChildren feature).\n\t\t\t\tvar frame_width=0, frame_height=0;\n\t\t\t\t\n\t\t\t\t// If the image has finished loading, go on and draw\n\t\t\t\tif (this.loaded) {\n\t\t\t\t\n\t\t\t\t\t// Draw current frame\n\t\t\t\t\tif (this.frames.length > 0) {\n\t\t\t\t\t\n\t\t\t\t\t\t// Get current frame\n\t\t\t\t\t\tif (this.frame > this.frames.length) {\n\n\t\t\t\t\t\t\t// Do clip with an empty path\n\t\t\t\t\t\t\tif(this.clipChildren) {\n\t\t\t\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\t\t\t\tcanvas.rect(x, y, 0, 0);\n\t\t\t\t\t\t\t\tcanvas.closePath();\n\t\t\t\t\t\t\t\tcanvas.clip();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tframe = this.frames[this.frame - 1];\n\t\t\t\t\t\tframe_width = (frame.w !== undefined) ? frame.w : this.width;\n\t\t\t\t\t\tframe_height = (frame.h !== undefined) ? frame.h : this.height;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Draw the current sprite part\n\t\t\t\t\t\tcanvas.drawImage(this.img, frame.x, frame.y, frame_width, frame_height, x, y, frame_width, frame_height);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Do stroke if stroke width is specified\n\t\t\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\t\t\t\t\t\t\tcanvas.strokeRect(x, y, frame_width, frame_height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set a redraw timer at the current frame duration if a timer is not already running\n\t\t\t\t\t\tif (this.running === false && this.active) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Increment the frame number only after the frame duration has passed\n\t\t\t\t\t\t\t\tif (_this.loop) {\n\t\t\t\t\t\t\t\t\t_this.frame = (_this.frame === _this.frames.length) ? 1 : _this.frame + 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_this.frame = (_this.frame === _this.frames.length) ? _this.frame : _this.frame + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Set timer status\n\t\t\t\t\t\t\t\t_this.running = false;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Redraw canvas if the timeline is not running\n\t\t\t\t\t\t\t\tif (!_this.core.timeline.running) {\n\t\t\t\t\t\t\t\t\t_this.core.draw.redraw();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}, frame.d);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set timer status\n\t\t\t\t\t\t\tthis.running = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Clear the timer if this is the first time it is drawn\n\t\t\t\t\tif (this.firstDrawn === false) {\n\t\t\t\t\t\tthis.firstDrawn = true;\n\t\t\t\t\t\tclearTimeout(this.loadtimer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If the image hasn't finished loading, set a timer and try again\n\t\t\t\telse {\n\t\t\t\t\tclearTimeout(this.loadtimer);\n\t\t\t\t\tthis.loadtimer = setTimeout(function () {\n\t\t\t\t\t\t_this.draw();\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\n\t\t\t\t// Do clip\n\t\t\t\tif(this.clipChildren) {\n\n\t\t\t\t\t// draw the clip region (the square area representing the current frame)\n\t\t\t\t\tcanvas.beginPath();\n\t\t\t\t\tcanvas.rect(x, y, frame_width, frame_height);\n\t\t\t\t\tcanvas.closePath();\n\n\t\t\t\t\tcanvas.clip();\n\n\t\t\t\t}\n\n\t\t\t\tthis._.hasBeenDrawn = true;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\tstart: function () {\n\t\t\t\tthis.startAnimation();\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tstartAnimation: function () {\n\t\t\t\tthis.active = true;\n\t\t\t\tthis.core.redraw();\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\tstopAnimation: function () {\n\t\t\t\tthis.active = false;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"sprite\", sprite, \"init\");\n\t\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/sprite.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/displayobjects/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/ocanvas/src/displayobjects/text.js ***!
  \*********************************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\tvar loadedFonts = [];\n\n\t// Define the class\n\tvar text = function (settings, thecore) {\n\t\n\t\t// Method for setting a font property. Updates both obj.font and obj.property\n\t\tvar setFontProperty = function (_this, property, value, objectProperty, thecore) {\n\t\t\tvar font = thecore.style.getFont(_this.font);\n\t\t\tfont[property] = value;\n\t\t\t_this._.font = thecore.style.getFont(font, \"string\");\n\t\t\tif (objectProperty === \"lineHeight\") {\n\t\t\t\t_this._.lineHeight = isNaN(parseInt(value, 10)) ? 1 : parseInt(value, 10);\n\t\t\t\t_this._.lineHeightUnit = typeof value === \"string\" ? (value.indexOf(\"px\") > -1 ? \"px\" : \"relative\") : \"relative\";\n\t\t\t} else {\n\t\t\t\t_this._[objectProperty] = value;\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn oCanvas.extend({\n\t\t\tcore: thecore,\n\t\t\t\n\t\t\tshapeType: \"rectangular\",\n\t\t\t\n\t\t\t// Default properties\n\t\t\talign: \"start\",\n\t\t\tbaseline: \"top\",\n\t\t\t_: oCanvas.extend({}, thecore.displayObject._, {\n\t\t\t\thasBeenDrawn: false,\n\t\t\t\tfont: \"normal normal normal 16px/1 sans-serif\",\n\t\t\t\tstyle: \"normal\",\n\t\t\t\tvariant: \"normal\",\n\t\t\t\tweight: \"normal\",\n\t\t\t\tsize: 16,\n\t\t\t\tlineHeight: 1,\n\t\t\t\tfamily: \"sans-serif\",\n\t\t\t\ttext: \"\",\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tlines: []\n\t\t\t}),\n\t\t\t\n\t\t\t// Setters for font properties\n\t\t\tset font (value) {\n\t\t\t\n\t\t\t\t// Convert the value to a correct string if it is not a string\n\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\tvalue = this.core.style.getFont(value, \"string\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get font object and set styles\n\t\t\t\tvar font = this.core.style.getFont(value);\n\t\t\t\tvalue = this.core.style.getFont(font, \"string\");\n\t\t\t\tthis._.style = font.style;\n\t\t\t\tthis._.variant = font.variant;\n\t\t\t\tthis._.weight = font.weight;\n\t\t\t\tthis._.size = font.size;\n\t\t\t\tthis._.lineHeight = font.lineHeight;\n\t\t\t\tthis._.lineHeightUnit = font.lineHeightUnit;\n\t\t\t\tthis._.family = font.family;\n\t\t\t\tthis._.font = value;\n\t\t\t\t\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset style (style) {\n\t\t\t\tsetFontProperty(this, \"style\", style, \"style\", this.core);\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset variant (variant) {\n\t\t\t\tsetFontProperty(this, \"variant\", variant, \"variant\", this.core);\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset weight (weight) {\n\t\t\t\tsetFontProperty(this, \"weight\", weight, \"weight\", this.core);\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset size (size) {\n\t\t\t\tsetFontProperty(this, \"size\", size, \"size\", this.core);\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset lineHeight (lineHeight) {\n\t\t\t\tsetFontProperty(this, \"lineHeight\", lineHeight, \"lineHeight\", this.core);\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset family (family) {\n\t\t\t\tsetFontProperty(this, \"family\", family, \"family\", this.core);\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset text (text) {\n\t\t\t\tthis._.text = text;\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\tset width (value) {\n\t\t\t\treturn;\n\t\t\t},\n\t\t\tset height (value) {\n\t\t\t\treturn;\n\t\t\t},\n\t\t\t\n\t\t\t// Getters for font properties\n\t\t\tget font () {\n\t\t\t\treturn this._.font;\n\t\t\t},\n\t\t\tget style () {\n\t\t\t\treturn this._.style;\n\t\t\t},\n\t\t\tget variant () {\n\t\t\t\treturn this._.variant;\n\t\t\t},\n\t\t\tget weight () {\n\t\t\t\treturn this._.weight;\n\t\t\t},\n\t\t\tget size () {\n\t\t\t\treturn this._.size;\n\t\t\t},\n\t\t\tget lineHeight () {\n\t\t\t\treturn this._.lineHeight + (this._.lineHeightUnit === \"px\" ? \"px\" : 0);\n\t\t\t},\n\t\t\tget family () {\n\t\t\t\treturn this._.family;\n\t\t\t},\n\t\t\tget text () {\n\t\t\t\treturn this._.text;\n\t\t\t},\n\t\t\tget width () {\n\t\t\t\treturn this._.width;\n\t\t\t},\n\t\t\tget height () {\n\t\t\t\treturn this._.height;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for initializing the text and get dimensions\n\t\t\tinit: function () {\n\t\t\t\tthis._.initialized = true;\n\t\t\t\tthis.initWebFont();\n\t\t\t\tthis.setDimensions();\n\t\t\t},\n\t\t\t\n\t\t\t// Method for setting width/height when something has changed\n\t\t\tsetDimensions: function () {\n\t\t\t\tif (this._.initialized) {\n\t\t\t\t\tvar canvas, textLines, numLines, lineHeight, width, height, i, metrics, lines;\n\n\t\t\t\t\tcanvas = this.core.canvas;\n\t\t\t\t\t\n\t\t\t\t\t// Set the text settings\n\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\tcanvas.font = this.font;\n\t\t\t\t\ttextLines = this.text.toString().split(\"\\n\");\n\t\t\t\t\tnumLines = textLines.length;\n\t\t\t\t\twidth = 0;\n\t\t\t\t\theight = 0;\n\t\t\t\t\tlines = [];\n\t\t\t\t\t\n\t\t\t\t\t// Get the dimensions of all lines\n\t\t\t\t\tfor (i = 0; i < numLines; i++) {\n\t\t\t\t\t\tmetrics = canvas.measureText(textLines[i]);\n\t\t\t\t\t\twidth = (metrics.width > width) ? metrics.width : width;\n\t\t\t\t\t\tif (this._.lineHeightUnit === \"px\") {\n\t\t\t\t\t\t\tlineHeight = this._.lineHeight;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlineHeight = this.size * this._.lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\theight += lineHeight;\n\t\t\t\t\t\tlines.push({\n\t\t\t\t\t\t\ttext: textLines[i],\n\t\t\t\t\t\t\twidth: metrics.width,\n\t\t\t\t\t\t\theight: lineHeight\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the dimensions\n\t\t\t\t\tthis._.width = width;\n\t\t\t\t\tthis._.height = height;\n\t\t\t\t\tthis._.lines = lines;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Method for initializing a web font.\n\t\t\t// Sometimes the font needs to be used once first to trigger it, before using it for the real text\n\t\t\tinitWebFont: function () {\n\t\t\t\tvar font = this.style + \" \" + this.variant + \" \" + this.weight + \" 0px \" + this.family;\n\n\t\t\t\tif (loadedFonts.indexOf(font) > -1) return;\n\t\t\t\tloadedFonts.push(font);\n\n\t\t\t\tvar self = this;\n\t\t\t\tvar core = this.core,\n\t\t\t\t\tdummy;\n\t\t\t\t\n\t\t\t\t// Create a dummy element and set the current font\n\t\t\t\tdummy = document.createElement(\"span\");\n\t\t\t\tdummy.style.font = font;\n\n\t\t\t\t// Append it to the DOM. This will trigger the web font to be used and available to the canvas\n\t\t\t\tdocument.body.appendChild(dummy);\n\n\t\t\t\t// Remove it after a second to not litter the DOM\n\t\t\t\t// Also redraw the canvas so text that didn't show before now appears\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tdocument.body.removeChild(dummy);\n\t\t\t\t\tif (self._.hasBeenDrawn) core.redraw();\n\t\t\t\t}, 1000);\n\t\t\t},\n\n\t\t\tgetAlignOffset: function () {\n\t\t\t\tvar aligns = {\n\t\t\t\t\t\"start\":  this.core.canvasElement.dir === \"rtl\" ? - this.width : 0,\n\t\t\t\t\t\"end\":    this.core.canvasElement.dir === \"rtl\" ? 0 : - this.width,\n\t\t\t\t\t\"left\":   0,\n\t\t\t\t\t\"center\": - this.width / 2,\n\t\t\t\t\t\"right\":  - this.width\n\t\t\t\t};\n\n\t\t\t\treturn aligns[this.align] || 0;\n\t\t\t},\n\t\t\t\n\t\t\tgetBaselineOffset: function () {\n\t\t\t\tvar baselines = {\n\t\t\t\t\t\"top\":         this.size *  0.82,\n\t\t\t\t\t\"hanging\":     this.size *  0.65,\n\t\t\t\t\t\"middle\":      this.size *  0.31,\n\t\t\t\t\t\"alphabetic\":  0,\n\t\t\t\t\t\"ideographic\": this.size * -0.05,\n\t\t\t\t\t\"bottom\":      this.size * -0.22\n\t\t\t\t};\n\n\t\t\t\treturn baselines[this.baseline] || 0;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for drawing the object to the canvas\n\t\t\tdraw: function () {\n\t\t\t\tvar canvas, lines, alignOffset, baselineOffset, relativeLineHeight, lineHeightOffset, origin, x, y, i, numLines;\n\n\t\t\t\tcanvas = this.core.canvas;\n\t\t\t\tlines = this._.lines;\n\n\t\t\t\talignOffset = this.getAlignOffset();\n\t\t\t\tbaselineOffset = this.getBaselineOffset();\n\t\t\t\trelativeLineHeight = this._.lineHeightUnit === \"px\" ? this._.lineHeight / this.size : this._.lineHeight;\n\t\t\t\tlineHeightOffset = (this.baseline !== \"top\") ? (this.size * (relativeLineHeight - 1)) / 2 : 0;\n\n\t\t\t\torigin = this.getOrigin();\n\t\t\t\tx = this.abs_x - origin.x - alignOffset;\n\t\t\t\ty = this.abs_y - origin.y + baselineOffset - lineHeightOffset;\n\t\t\t\t\n\t\t\t\tcanvas.beginPath();\n\t\t\t\t\n\t\t\t\tcanvas.font = this.font;\n\t\t\t\tcanvas.textAlign = this.align;\n\t\t\t\tcanvas.textBaseline = \"alphabetic\";\n\t\t\t\t\n\t\t\t\t// Draw the text as a stroke if a stroke is specified\n\t\t\t\tif (this.strokeWidth > 0) {\n\t\t\t\t\tcanvas.lineWidth = this.strokeWidth;\n\t\t\t\t\tcanvas.strokeStyle = this.strokeColor;\n\n\t\t\t\t\t// Draw the text with support for multiple lines\n\t\t\t\t\tfor (i = 0, numLines = lines.length; i < numLines; i++) {\n\t\t\t\t\t\tcanvas.strokeText(lines[i].text, x, y + (i * lines[i].height) + (lines[i].height - this.size) / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Draw the text normally if a fill color is specified\n\t\t\t\tif (this.fill !== \"\") {\n\t\t\t\t\tcanvas.fillStyle = this.fill;\n\t\t\t\t\t\n\t\t\t\t\t// Draw the text with support for multiple lines\n\t\t\t\t\tfor (i = 0, numLines = lines.length; i < numLines; i++) {\n\t\t\t\t\t\tcanvas.fillText(lines[i].text, x, y + (i * lines[i].height) + (lines[i].height - this.size) / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcanvas.closePath();\n\n\t\t\t\tthis._.hasBeenDrawn = true;\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t}, settings);\n\t};\n\t\n\t// Register the display object\n\toCanvas.registerDisplayObject(\"text\", text, \"init\");\n\t\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/displayobjects/text.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/draw.js":
/*!******************************************!*\
  !*** ./node_modules/ocanvas/src/draw.js ***!
  \******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar draw = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\t// Set properties\n\t\t\tobjects: [],\n\t\t\ttranslation: { x: 0, y: 0 },\n\n\t\t\tchangeZorder: function (obj, index1, index2) {\n\t\t\t\tvar objects = obj.children,\n\t\t\t\t\tobj1 = objects[index1],\n\t\t\t\t\tobj2 = objects[index2],\n\t\t\t\t\tbefore, middle, after, newArray;\n\n\t\t\t\t// Cancel the change if the first object doesn't exist\n\t\t\t\tif (obj1 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Cancel the change if the indexes are the same\n\t\t\t\tif (index1 === index2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If the new index is larger than the last index, make it the last\n\t\t\t\tif (index2 > objects.length -1) {\n\t\t\t\t\tindex2 = objects.length -1;\n\t\t\t\t}\n\n\t\t\t\t// If the new index is smaller than the first, make it the first\n\t\t\t\tif (index2 < 0) {\n\t\t\t\t\tindex2 = 0;\n\t\t\t\t}\n\n\t\t\t\t// Change the order of the objects\n\t\t\t\tif (index2 > index1) {\n\t\t\t\t\tbefore = objects.slice(0, index1);\n\t\t\t\t\tafter = objects.slice(index2 + 1, objects.length);\n\t\t\t\t\tmiddle = objects.slice(index1, index2 + 1);\n\t\t\t\t\tmiddle.shift();\n\t\t\t\t\tmiddle.push(obj1);\n\t\t\t\t} else {\n\t\t\t\t\tbefore = objects.slice(0, index2);\n\t\t\t\t\tafter = objects.slice(index1 + 1, objects.length);\n\t\t\t\t\tmiddle = objects.slice(index2, index1 + 1);\n\t\t\t\t\tmiddle.pop();\n\t\t\t\t\tmiddle.unshift(obj1);\n\t\t\t\t}\n\n\t\t\t\t// Update the array with the new values\n\t\t\t\tobj.children = before.concat(middle).concat(after);\n\t\t\t},\n\t\t\t\n\t\t\t// Method for clearing the canvas from everything that has been drawn (bg can be kept)\n\t\t\tclear: function (keepBackground) {\n\n\t\t\t\t// Clear all the image data on the canvas\n\t\t\t\tthis.core.canvas.clearRect(0, 0, this.core.width, this.core.height);\n\t\t\t\t\n\t\t\t\t// Redraw the background if it should be kept\n\t\t\t\tif (keepBackground !== false) {\n\t\t\t\t\tthis.core.background.redraw();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set a flag that will affect the value of the `drawn` property of display objects\n\t\t\t\tthis.isCleared = true;\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for drawing all objects in the object list\n\t\t\tredraw: function (forceClear) {\n\t\t\t\tforceClear = forceClear || false;\n\t\t\t\t\n\t\t\t\t// Clear the canvas (keep the background)\n\t\t\t\tif (this.core.settings.clearEachFrame || forceClear) {\n\t\t\t\t\tthis.clear();\n\t\t\t\t}\n\n\t\t\t\t// Set a flag that will affect the value of the `drawn` property of display objects\n\t\t\t\tthis.isCleared = false;\n\n\t\t\t\t// Draw all objects in the correct order\n\t\t\t\tthis.drawObjects(this.core.children);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tdrawObjects: function (objects) {\n\t\t\t\tvar canvas = this.core.canvas,\n\t\t\t\t\ti, l, obj, object, x, y, objectChain, lastX, lastY, n, len, parent, shadow, opacity;\n\n\t\t\t\tfor (i = 0, l = objects.length; i < l; i++) {\n\t\t\t\t\tobj = objects[i];\n\t\t\t\t\tif ((obj !== undefined) && (typeof obj.draw === \"function\")) {\n\n\t\t\t\t\t\t// Reset canvas properties to their default values\n\t\t\t\t\t\tcanvas.strokeStyle = \"#000\";\n\t\t\t\t\t\tcanvas.fillStyle = \"#000\";\n\t\t\t\t\t\tcanvas.globalAlpha = 1;\n\t\t\t\t\t\tcanvas.lineWidth = 1;\n\t\t\t\t\t\tcanvas.lineCap = \"butt\";\n\t\t\t\t\t\tcanvas.lineJoin = \"miter\";\n\t\t\t\t\t\tcanvas.miterLimit = 10;\n\t\t\t\t\t\tcanvas.lineDashOffset = 0;\n\t\t\t\t\t\tcanvas.shadowOffsetX = 0;\n\t\t\t\t\t\tcanvas.shadowOffsetY = 0;\n\t\t\t\t\t\tcanvas.shadowBlur = 0;\n\t\t\t\t\t\tcanvas.shadowColor = 'rgba(0, 0, 0, 0)';\n\t\t\t\t\t\tcanvas.globalCompositeOperation = 'source-over';\n\t\t\t\t\t\tcanvas.font = '10px sans-serif';\n\t\t\t\t\t\tcanvas.textAlign = 'start';\n\t\t\t\t\t\tcanvas.textBaseline = 'alphabetic';\n\t\t\t\t\t\tcanvas.direction = 'inherit';\n\t\t\t\t\t\tcanvas.imageSmoothingEnabled = true;\n\n\t\t\t\t\t\t// Update the object's properties if an update method is available\n\t\t\t\t\t\tif (typeof obj.update === \"function\") {\n\t\t\t\t\t\t\tobj.update();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Temporarily move the canvas origin and take children's positions into account, so they will rotate around the parent\n\t\t\t\t\t\tcanvas.save();\n\n\t\t\t\t\t\t// Translate the canvas matrix to the position of the object\n\t\t\t\t\t\tcanvas.translate(obj.x, obj.y);\n\n\t\t\t\t\t\t// If the object has a rotation, rotate the canvas matrix\n\t\t\t\t\t\tif (obj.rotation !== 0) {\n\t\t\t\t\t\t\tcanvas.rotate(obj.rotation * Math.PI / 180);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Scale the canvas for this object\n\t\t\t\t\t\tif (obj.scalingX !== 1 || obj.scalingY !== 1) {\n\t\t\t\t\t\t\tcanvas.scale(obj.scalingX, obj.scalingY);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Scale the opacity\n\t\t\t\t\t\topacity = obj.opacity;\n\t\t\t\t\t\tvar parent = obj.parent;\n\t\t\t\t\t\twhile(parent && parent !== this.core) {\n\t\t\t\t\t\t\topacity *= parent.opacity;\n\t\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save the translation so that display objects can access this if they need\n\t\t\t\t\t\tthis.translation = { x: obj.abs_x, y: obj.abs_y };\n\n\t\t\t\t\t\t// Automatically adjust the abs_x/abs_y for the object\n\t\t\t\t\t\t// (objects not using these variables in the drawing process use the object created above)\n\t\t\t\t\t\tx = obj.abs_x;\n\t\t\t\t\t\ty = obj.abs_y;\n\t\t\t\t\t\tobj._.abs_x = 0;\n\t\t\t\t\t\tobj._.abs_y = 0;\n\n\t\t\t\t\t\t// Set the alpha to match the object's opacity\n\t\t\t\t\t\tcanvas.globalAlpha = !isNaN(parseFloat(opacity)) ? parseFloat(opacity) : 1;\n\n\t\t\t\t\t\t// Set the composition mode\n\t\t\t\t\t\tcanvas.globalCompositeOperation = obj.composition;\n\n\t\t\t\t\t\t// Set shadow properties if object has shadow\n\t\t\t\t\t\tshadow = obj.shadow;\n\t\t\t\t\t\tif (shadow.blur > 0) {\n\t\t\t\t\t\t\tcanvas.shadowOffsetX = shadow.offsetX;\n\t\t\t\t\t\t\tcanvas.shadowOffsetY = shadow.offsetY;\n\t\t\t\t\t\t\tcanvas.shadowBlur = shadow.blur;\n\t\t\t\t\t\t\tcanvas.shadowColor = shadow.color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set stroke properties\n\t\t\t\t\t\tcanvas.lineCap = obj.cap;\n\t\t\t\t\t\tcanvas.lineJoin = obj.join;\n\t\t\t\t\t\tcanvas.miterLimit = obj.miterLimit;\n\n\t\t\t\t\t\t// Draw the object\n\t\t\t\t\t\tobj.draw();\n\t\t\t\t\t\tobj.drawn = true;\n\n\t\t\t\t\t\t// Reset the abs_x/abs_y values\n\t\t\t\t\t\tobj._.abs_x = x;\n\t\t\t\t\t\tobj._.abs_y = y;\n\n\t\t\t\t\t\t// Loop children recursively to draw everything in the correct order\n\t\t\t\t\t\tif (obj.children.length > 0) {\n\t\t\t\t\t\t\tthis.drawObjects(obj.children);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Restore the old transformation\n\t\t\t\t\t\tcanvas.restore();\n\t\t\t\t\t\tthis.translation = { x: 0, y: 0 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"draw\", draw);\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/draw.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/events.js":
/*!********************************************!*\
  !*** ./node_modules/ocanvas/src/events.js ***!
  \********************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar events = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\tenabled: true,\n\t\t\teventTypes: {},\n\n\t\t\tinit: function () {\n\n\t\t\t\t// Add core properties that this module needs to be able to add events directly to the canvas\n\t\t\t\tthis.core.canvasElement.events = {};\n\t\t\t},\n\n\t\t\taddEventTypes: function (pointerName, types) {\n\t\t\t\tthis.eventTypes[pointerName] = this.eventTypes[pointerName] || [];\n\t\t\t\tvar eventTypes = this.eventTypes[pointerName];\n\t\t\t\tfor (var group in types) {\n\t\t\t\t\teventTypes[group] = eventTypes[group] || [];\n\t\t\t\t\teventTypes[group].push(types[group]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbind: function (obj, types, handler) {\n\t\t\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\t\t\tobj.events[types[i]] = obj.events[types[i]] || [];\n\t\t\t\t\tobj.events[types[i]].push(handler);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tunbind: function (obj, types, handler) {\n\t\t\t\tvar i, handlers, index;\n\n\t\t\t\tfor (i = 0; i < types.length; i++) {\n\t\t\t\t\thandlers = obj.events[types[i]];\n\n\t\t\t\t\t// If no handlers have been added, none can be removed\n\t\t\t\t\tif (handlers === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove all handlers if no specific handler is passed in\n\t\t\t\t\tif (handler === undefined) {\n\t\t\t\t\t\tdelete obj.events[types[i]];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find the passed in handler and remove it\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex = handlers.indexOf(handler);\n\t\t\t\t\t\tif (~index) {\n\t\t\t\t\t\t\thandlers.splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfindFrontObject: function (objects, pointer) {\n\t\t\t\tvar i, obj, result;\n\n\t\t\t\t// No object can be found if there are no objects\n\t\t\t\tif (objects.length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Go through each object, starting from the end.\n\t\t\t\t//  For each object, it will loop through that object's children recursively.\n\t\t\t\t//  That way we start with the front object for the root level (added to core)\n\t\t\t\t//  and dig through to the deepest child. If the pointer is inside that object,\n\t\t\t\t//  we break out of all loops and return that object to the original caller.\n\t\t\t\t//  If the pointer was not inside that object, we will go back out one step\n\t\t\t\t//  at a time and check the pointer against each object. If no object was\n\t\t\t\t//  detected and we reach the core child again, we will take the next core\n\t\t\t\t//  child and iterate through that child chain.\n\t\t\t\tfor (i = objects.length; i--;) {\n\t\t\t\t\tobj = objects[i];\n\t\t\t\t\tresult = this.findFrontObject(obj.children, pointer);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tif (obj.pointerEvents && obj.isPointerInside(pointer)) {\n\t\t\t\t\t\t\tresult = obj;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// This function will return an object if the pointer is inside it, or false otherwise\n\t\t\t\treturn result;\n\t\t\t},\n\n\t\t\tgetFrontObject: function (pointerName) {\n\t\t\t\treturn this.findFrontObject(this.core.children, this.core[pointerName]) || undefined;\n\t\t\t},\n\n\t\t\ttriggerPointerEvent: function (type, frontObject, pointerName, e) {\n\n\t\t\t\t// Abort if events are disabled\n\t\t\t\tif (!this.enabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar canvas, eventTypes, enterEvent, leaveEvent, typeEvent,\n\t\t\t\t    clickEvent, parentChain, chain, sharedParent, i, l;\n\n\t\t\t\tcanvas = this.core.canvasElement;\n\t\t\t\teventTypes = this.eventTypes[pointerName];\n\t\t\t\tenterEvent = eventTypes.enter;\n\t\t\t\tleaveEvent = eventTypes.leave;\n\t\t\t\ttypeEvent = eventTypes[type];\n\t\t\t\tclickEvent = eventTypes.singleClick;\n\n\t\t\t\t// Get a fixed event object\n\t\t\t\tthis.lastPointerEventObject = this.fixEventObject(e, pointerName);\n\n\t\t\t\t// Was any front object found?\n\t\t\t\tif (frontObject) {\n\n\t\t\t\t\t// Is this a different object than the current front object?\n\t\t\t\t\tif (frontObject !== this.frontObject) {\n\n\t\t\t\t\t\t// Is there a current front object?\n\t\t\t\t\t\tif (this.frontObject) {\n\n\t\t\t\t\t\t\t// Is the current front object not in the parent chain for this object?\n\t\t\t\t\t\t\tparentChain = this.getParentChain(frontObject);\n\t\t\t\t\t\t\tif (!~parentChain.indexOf(this.frontObject)) {\n\t\t\t\t\t\t\t\tthis.triggerHandlers(this.frontObject, leaveEvent);\n\n\t\t\t\t\t\t\t\t// Is this object not in the parent chain for the current front object?\n\t\t\t\t\t\t\t\tparentChain = this.getParentChain(this.frontObject);\n\t\t\t\t\t\t\t\tif (!~parentChain.indexOf(frontObject)) {\n\t\t\t\t\t\t\t\t\tthis.triggerChain(parentChain, leaveEvent);\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// This object is in the parent chain, so we construct a new chain\n\t\t\t\t\t\t\t\t\t//   for all parents in between and trigger leave events for this chain\n\t\t\t\t\t\t\t\t\tchain = [];\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = parentChain.length; i < l; i++) {\n\t\t\t\t\t\t\t\t\t\tif (parentChain[i] === frontObject) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tchain.push(parentChain[i]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis.triggerChain(chain, leaveEvent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set this object as new front object\n\t\t\t\t\t\tthis.frontObject = frontObject;\n\n\t\t\t\t\t\t// Has the pointer not entered the parent of this object?\n\t\t\t\t\t\tif (!(frontObject.parent || canvas).events.hasEntered) {\n\n\t\t\t\t\t\t\t// Trigger all enter handlers for all parents that the pointer hasn't entered (out to in)\n\t\t\t\t\t\t\tparentChain = this.findNonEnteredParentChain(frontObject);\n\t\t\t\t\t\t\tthis.triggerChain(parentChain, enterEvent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Has the pointer not entered this object?\n\t\t\t\t\t\tif (!frontObject.events.hasEntered) {\n\t\t\t\t\t\t\tthis.triggerHandlers(frontObject, enterEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Is there a current front object?\n\t\t\t\t\tif (this.frontObject) {\n\n\t\t\t\t\t\t// Get the parent chain for the object and add the current object to the beginning\n\t\t\t\t\t\tchain = this.getParentChain(this.frontObject, false, true);\n\n\t\t\t\t\t\t// Trigger all leave handlers for current front object and parent chain\n\t\t\t\t\t\tthis.triggerChain(chain, leaveEvent);\n\n\t\t\t\t\t\tthis.frontObject = null;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Trigger all enter handlers for the canvas if it hasn't been entered\n\t\t\t\t\t\tif (!canvas.events.hasEntered) {\n\t\t\t\t\t\t\tthis.triggerHandlers(canvas, enterEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfrontObject = this.core.canvasElement;\n\t\t\t\t}\n\n\t\t\t\t// Save which object the pointer was last pressed down on\n\t\t\t\tif (type === \"down\") {\n\t\t\t\t\tthis.lastDownObject = frontObject;\n\t\t\t\t}\n\n\t\t\t\t// Trigger all handlers of the current type, for the object and its parent chain, including canvas\n\t\t\t\t//   This will also respect stopPropagation(), since the event will not be an enter or leave event\n\t\t\t\tchain = this.getParentChain(frontObject, true, true);\n\t\t\t\tthis.triggerChain(chain, typeEvent);\n\n\t\t\t\t// If this is an up event, we might also want to trigger click events\n\t\t\t\tif (type === \"up\") {\n\n\t\t\t\t\t// Is this object the last object the pointer was pressed down on?\n\t\t\t\t\tif (frontObject === this.lastDownObject) {\n\n\t\t\t\t\t\t// Trigger all click handlers for the object and its parent chain, including canvas\n\t\t\t\t\t\tthis.triggerChain(chain, clickEvent);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Get the shared parent for this object and the last object the pointer was pressed down\n\t\t\t\t\t\tsharedParent = this.getSharedParent(frontObject, this.lastDownObject);\n\t\t\t\t\t\tif (sharedParent) {\n\n\t\t\t\t\t\t\t// Trigger all click handlers for the shared parent and its parent chain, incl canvas\n\t\t\t\t\t\t\tchain = this.getParentChain(sharedParent, true, true);\n\t\t\t\t\t\t\tthis.triggerChain(chain, clickEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.lastDownObject = null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetSharedParent: function (obj1, obj2) {\n\t\t\t\tvar obj1Chain, canvas, obj2Parent;\n\n\t\t\t\tobj1Chain = this.getParentChain(obj1, true, true);\n\n\t\t\t\tcanvas = this.core.canvasElement;\n\t\t\t\tobj2Parent = obj2;\n\n\t\t\t\twhile (obj2Parent) {\n\t\t\t\t\tif (~obj1Chain.indexOf(obj2Parent)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tobj2Parent = obj2Parent.parent || (obj2Parent !== canvas ? canvas : undefined);\n\t\t\t\t}\n\n\t\t\t\treturn obj2Parent;\n\t\t\t},\n\n\t\t\tfindNonEnteredParentChain: function (obj) {\n\t\t\t\tvar chain, canvas, parent;\n\n\t\t\t\tchain = [];\n\t\t\t\tcanvas = this.core.canvasElement;\n\t\t\t\tparent = obj.parent;\n\n\t\t\t\twhile (parent) {\n\t\t\t\t\tif (parent.events.hasEntered) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchain.push(parent);\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t}\n\n\t\t\t\tif (!parent && !canvas.events.hasEntered) {\n\t\t\t\t\tchain.push(canvas);\n\t\t\t\t}\n\n\t\t\t\treturn chain.reverse();\n\t\t\t},\n\n\t\t\tgetParentChain: function (obj, includeCanvas, includeObj) {\n\t\t\t\tvar chain, parent;\n\t\t\t\tchain = [];\n\n\t\t\t\tif (includeObj) {\n\t\t\t\t\tchain.push(obj);\n\t\t\t\t}\n\n\t\t\t\tparent = obj.parent;\n\t\t\t\twhile (parent) {\n\t\t\t\t\tchain.push(parent);\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t}\n\n\t\t\t\tif (includeCanvas && obj !== this.core.canvasElement) {\n\t\t\t\t\tchain.push(this.core.canvasElement);\n\t\t\t\t}\n\n\t\t\t\treturn chain;\n\t\t\t},\n\n\t\t\ttriggerChain: function (chain, types, eventObject) {\n\t\t\t\tvar i, l, continuePropagation;\n\t\t\t\tfor (i = 0, l = chain.length; i < l; i++) {\n\t\t\t\t\tcontinuePropagation = this.triggerHandlers(chain[i], types, eventObject);\n\t\t\t\t\tif (!continuePropagation) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttriggerHandlers: function (obj, types, eventObject) {\n\t\t\t\tvar i, handlers, isEnter, isLeave, numHandlers, n, e;\n\n\t\t\t\tvar callObj = (obj === this.core.canvasElement) ? this.core : obj;\n\n\t\t\t\tfor (i = 0; i < types.length; i++) {\n\t\t\t\t\thandlers = obj.events[types[i]];\n\t\t\t\t\tisEnter = !!~types[i].indexOf(\"enter\");\n\t\t\t\t\tisLeave = !!~types[i].indexOf(\"leave\");\n\t\t\t\t\te = eventObject || (~types[i].indexOf(\"key\") ? this.lastKeyboardEventObject : this.lastPointerEventObject);\n\t\t\t\t\te.type = types[i];\n\t\t\t\t\te.bubbles = (isEnter || isLeave) ? false : true;\n\n\t\t\t\t\tif (isEnter && !obj.events.hasEntered) {\n\t\t\t\t\t\tobj.events.hasEntered = true;\n\t\t\t\t\t} else if (isLeave && obj.events.hasEntered) {\n\t\t\t\t\t\tobj.events.hasEntered = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (handlers) {\n\t\t\t\t\t\tnumHandlers = handlers.length;\n\t\t\t\t\t\tfor (n = 0; n < numHandlers; n++) {\n\t\t\t\t\t\t\tif (typeof handlers[n] === \"function\") {\n\t\t\t\t\t\t\t\thandlers[n].call(callObj, e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e.stoppingPropagation) {\n\t\t\t\t\t\t\te.stoppingPropagation = false;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tfixEventObject: function (e, inputName) {\n\t\t\t\tvar properties = \"altKey ctrlKey metaKey shiftKey button charCode keyCode clientX clientY pageX pageY screenX screenY detail eventPhase isChar touches targetTouches changedTouches scale rotation\".split(\" \"),\n\t\t\t\t\tnumProps = properties.length,\n\t\t\t\t\teventObject, i, property, buttonConversion;\n\t\t\t\t\n\t\t\t\t// Fix specific properties and methods\n\t\t\t\teventObject = {\n\t\t\t\t\toriginalEvent: e,\n\t\t\t\t\ttimeStamp: (new Date()).getTime(),\n\t\t\t\t\twhich: e === undefined ? 0 : (e.which === 0 ? e.keyCode : e.which),\n\t\t\t\t\t\n\t\t\t\t\tpreventDefault: function () {\n\t\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\n\t\t\t\t\tstopPropagation: function () {\n\t\t\t\t\t\tif (this.bubbles) {\n\t\t\t\t\t\t\tthis.stoppingPropagation = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (e === undefined) {\n\t\t\t\t\treturn eventObject;\n\t\t\t\t}\n\n\t\t\t\t// Set selected original properties\n\t\t\t\tfor (i = 0; i < numProps; i++) {\n\t\t\t\t\tproperty = properties[i];\n\t\t\t\t\tif (e[property] !== undefined) {\n\t\t\t\t\t\teventObject[property] = e[property];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add pointer coordinates\n\t\t\t\tif (~\"mouse touch\".indexOf(inputName)) {\n\t\t\t\t\teventObject.x = this.core[inputName].x;\n\t\t\t\t\teventObject.y = this.core[inputName].y;\n\t\t\t\t}\n\n\t\t\t\t// Fix the which property for mouse events\n\t\t\t\tif (inputName === \"mouse\") {\n\t\t\t\t\t// 0: No button pressed\n\t\t\t\t\t// 1: Primary button (usually left)\n\t\t\t\t\t// 2: Secondary button (usually right)\n\t\t\t\t\t// 3: Middle (usually the wheel)\n\t\t\t\t\tbuttonConversion = {\n\t\t\t\t\t\t0: 1,\n\t\t\t\t\t\t2: 2,\n\t\t\t\t\t\t1: 3,\n\t\t\t\t\t\t\"default\": 0\n\t\t\t\t\t};\n\t\t\t\t\teventObject.which = buttonConversion[eventObject.button] || buttonConversion[\"default\"];\n\t\t\t\t}\n\n\t\t\t\t// Fix the which property for touch events\n\t\t\t\tif (inputName === \"touch\") {\n\t\t\t\t\teventObject.which = 0;\n\t\t\t\t}\n\n\t\t\t\treturn eventObject;\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"events\", events, \"init\");\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/events.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/keyboard.js":
/*!**********************************************!*\
  !*** ./node_modules/ocanvas/src/keyboard.js ***!
  \**********************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar keyboard = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\t\t\t\n\t\t\tkeysDown: {},\n\t\t\tkeyPressTimers: {},\n\t\t\tmodifiedKeys: [],\n\t\t\t\n\t\t\t// Method for initializing the keyboard object\n\t\t\tinit: function () {\n\t\t\t\tvar self = this;\n\n\t\t\t\toCanvas.addDOMEventHandler(this.core, document, \"keydown\", function (e) { self.docHandler(e); }, false);\n\t\t\t\toCanvas.addDOMEventHandler(this.core, document, \"keyup\", function (e) { self.docHandler(e); }, false);\n\t\t\t\toCanvas.addDOMEventHandler(this.core, document, \"keypress\", function (e) { self.preventDefault(e); }, false);\n\t\t\t},\n\n\t\t\tdocHandler: function (e) {\n\t\t\t\tvar keyCode, events, canvasElement, eventObject;\n\t\t\t\tevents = this.core.events;\n\t\t\t\tcanvasElement = this.core.canvasElement;\n\n\t\t\t\t// Abort if events are disabled\n\t\t\t\tif (!events.enabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Only trigger events if the pointer has set focus to the canvas\n\t\t\t\t//  or if there are no pointers registered\n\t\t\t\tif (this.core.pointer && this.core.pointer.canvasFocused !== true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tkeyCode = this.getKeyCode(e);\n\n\t\t\t\t// Prevent default for keys that have been added to the prevent list\n\t\t\t\tthis.preventDefault(e);\n\t\t\t\n\t\t\t\t// Cancel event if the key is already pressed down\n\t\t\t\t// (some browsers repeat even keydown when held down)\n\t\t\t\tif (e.type === \"keydown\" && this.keysDown[keyCode] === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the key states when pressed down\n\t\t\t\tif (e.type === \"keydown\") {\n\t\t\t\t\tthis.keysDown[keyCode] = true;\n\t\t\t\t} else if (e.type === \"keyup\") {\n\t\t\t\t\tdelete this.keysDown[keyCode];\n\t\t\t\t}\n\n\t\t\t\t// Get a fixed event object\n\t\t\t\teventObject = events.fixEventObject(e, \"keyboard\");\n\t\t\t\tevents.lastKeyboardEventObject = eventObject;\n\n\t\t\t\t// Trigger events\n\t\t\t\tevents.triggerHandlers(canvasElement, [e.type]);\n\n\t\t\t\t// Set the timer to trigger keypress events continuously until released\n\t\t\t\tif (e.type === \"keydown\") {\n\t\t\t\t\tthis.keyPressTimers[keyCode] = setInterval(function () {\n\t\t\t\t\t\tevents.triggerHandlers(canvasElement, [\"keypress\"], eventObject);\n\t\t\t\t\t}, 1000 / this.core.settings.fps);\n\t\t\t\t}\n\n\t\t\t\t// If there are no more keys pressed down, cancel the keypress timers\n\t\t\t\tif (e.type === \"keyup\") {\n\t\t\t\t\tif (!this.anyKeysDown()) {\n\t\t\t\t\t\tfor (keyCode in this.keyPressTimers) {\n\t\t\t\t\t\t\tclearInterval(this.keyPressTimers[keyCode]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclearInterval(this.keyPressTimers[keyCode]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for preventing the default behavior of the assigned keys\n\t\t\tpreventDefault: function (e) {\n\t\t\t\tif ((this.core.mouse && this.core.mouse.canvasFocused === true) || !this.core.mouse) {\n\t\t\t\t\tvar keyCode = this.getKeyCode(e);\n\n\t\t\t\t\tif (~this.modifiedKeys.indexOf(keyCode)) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for adding keys that will have the default actions prevented\n\t\t\taddPreventDefaultFor: function (keys) {\n\t\t\t\t\n\t\t\t\t// Fix the keys array\n\t\t\t\tkeys = (typeof keys === \"number\") ? [keys] : ((keys instanceof Array) ? keys : []);\n\t\t\t\t\n\t\t\t\t// Add the keys\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tthis.modifiedKeys.push(keys[i]);\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for removing keys that will no longer have the default actions prevented\n\t\t\tremovePreventDefaultFor: function (keys) {\n\t\t\t\t\n\t\t\t\t// Fix the keys array\n\t\t\t\tkeys = (typeof keys === \"number\") ? [keys] : ((keys instanceof Array) ? keys : []);\n\t\t\t\t\n\t\t\t\t// Remove the keys\n\t\t\t\tvar i, index;\n\t\t\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\t\t\tindex = this.modifiedKeys.indexOf(keys[i]);\n\t\t\t\t\tif (~index) {\n\t\t\t\t\t\tthis.modifiedKeys.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for getting the key code from current event\n\t\t\tgetKeyCode: function (e) {\n\t\t\t\treturn e.keyCode === 0 ? e.which : e.keyCode;\n\t\t\t},\n\n\t\t\t// Method for getting how many keys are currently pressed down\n\t\t\tnumKeysDown: function () {\n\t\t\t\tvar numKeys, keysDown, keyCode;\n\t\t\t\tnumKeys = 0;\n\t\t\t\tkeysDown = this.keysDown;\n\n\t\t\t\t// Go through all the keys that are currently pressed down\n\t\t\t\tfor (keyCode in keysDown) {\n\t\t\t\t\tif (keysDown[keyCode] === true) {\n\t\t\t\t\t\tnumKeys++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn numKeys;\n\t\t\t},\n\n\t\t\t// Method for checking if any keys are pressed down\n\t\t\tanyKeysDown: function () {\n\t\t\t\treturn this.numKeysDown() > 0;\n\t\t\t},\n\n\t\t\t// Method for getting which keys are currently pressed down\n\t\t\tgetKeysDown: function () {\n\t\t\t\tvar keysDown, currentlyDown, keyCode;\n\t\t\t\tkeysDown = this.keysDown;\n\t\t\t\tcurrentlyDown = [];\n\n\t\t\t\t// Go through all the keys that are currently pressed down\n\t\t\t\tfor (keyCode in keysDown) {\n\t\t\t\t\tif (keysDown[keyCode] === true) {\n\t\t\t\t\t\tcurrentlyDown.push(parseInt(keyCode, 10));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn currentlyDown;\n\t\t\t},\n\t\t\t\n\t\t\tARROW_UP:38, ARROW_DOWN:40, ARROW_LEFT:37, ARROW_RIGHT:39, SPACE:32, ENTER:13, ESC:27\n\t\t};\n\t};\n\t\n\t// Register the module\n\toCanvas.registerModule(\"keyboard\", keyboard, \"init\");\n\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/keyboard.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/mouse.js":
/*!*******************************************!*\
  !*** ./node_modules/ocanvas/src/mouse.js ***!
  \*******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar mouse = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tbuttonState: \"up\",\n\t\t\tcanvasFocused: false,\n\t\t\tcanvasHovered: false,\n\t\t\tcursorValue: \"default\",\n\n\t\t\tinit: function () {\n\n\t\t\t\tthis.core.events.addEventTypes(\"mouse\", {\n\t\t\t\t\tmove: \"mousemove\",\n\t\t\t\t\tenter: \"mouseenter\",\n\t\t\t\t\tleave: \"mouseleave\",\n\t\t\t\t\tdown: \"mousedown\",\n\t\t\t\t\tup: \"mouseup\",\n\t\t\t\t\tsingleClick: \"click\",\n\t\t\t\t\tdoubleClick: \"dblclick\"\n\t\t\t\t});\n\n\t\t\t\tthis.types = {\n\t\t\t\t\t\"mousemove\": \"move\",\n\t\t\t\t\t\"mousedown\": \"down\",\n\t\t\t\t\t\"mouseup\": \"up\",\n\t\t\t\t\t\"dblclick\": \"doubleClick\"\n\t\t\t\t};\n\n\t\t\t\tthis.core.pointer = this;\n\n\t\t\t\t// Only bind events for mouse if touch is not available\n\t\t\t\t//  This is to enable developers to bind to both touch and mouse,\n\t\t\t\t//  but still only trigger handlers once (for the right input device)\n\t\t\t\tif (!this.core.touch || !this.core.touch.isTouch) {\n\t\t\t\t\tthis.bindHandlers();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbindHandlers: function () {\n\t\t\t\tvar self, core, canvasElement, type;\n\t\t\t\t\n\t\t\t\tself = this;\n\t\t\t\tcore = this.core;\n\t\t\t\tcanvasElement = core.canvasElement;\n\n\t\t\t\tfor (type in this.types) {\n\n\t\t\t\t\t// Add event listeners to the canvas element\n\t\t\t\t\toCanvas.addDOMEventHandler(core, canvasElement, type, function (e) {\n\t\t\t\t\t\tself.canvasHandler(e);\n\t\t\t\t\t}, false);\n\n\t\t\t\t\t// Add event listeners to the document (used for setting states and trigger mouseup events)\n\t\t\t\t\tif (type === \"mousemove\") {\n\t\t\t\t\t\ttype = \"mouseover\";\n\t\t\t\t\t}\n\t\t\t\t\toCanvas.addDOMEventHandler(core, document, type, function (e) {\n\t\t\t\t\t\tself.docHandler(e);\n\t\t\t\t\t}, false);\n\n\t\t\t\t\t// We also want to listen to events on the parent document to detect pointer movements\n\t\t\t\t\t// to and from this document.\n\t\t\t\t\t//\n\t\t\t\t\t// Wrap in try...catch in case the documents are of different origins (since that will\n\t\t\t\t\t// throw an exception). This functionality is not strictly needed, but if we can access\n\t\t\t\t\t// the parent document we can provide better pointer event detection between the\n\t\t\t\t\t// documents.\n\t\t\t\t\tvar parentDocument = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparentDocument = window.parent.document;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (parentDocument) {\n\t\t\t\t\t\toCanvas.addDOMEventHandler(core, parentDocument, type, function (e) {\n\t\t\t\t\t\t\tself.docHandler(e);\n\t\t\t\t\t\t}, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcanvasHandler: function (e, fromDoc) {\n\t\t\t\tvar events, onCanvas, type, frontObject;\n\n\t\t\t\tevents = this.core.events;\n\t\t\t\tonCanvas = this.onCanvas(e);\n\n\t\t\t\t// Trigger only mouseup events if pointer is outside the canvas\n\t\t\t\tif (e.type === \"mouseup\" && !onCanvas && !this.canvasUpEventTriggered) {\n\t\t\t\t\tevents.triggerPointerEvent(this.types[\"mouseup\"], events.frontObject, \"mouse\", e);\n\t\t\t\t\tevents.triggerPointerEvent(this.types[\"mouseup\"], this.core.canvasElement, \"mouse\", e);\n\t\t\t\t\tthis.canvasUpEventTriggered = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Abort the handler if the pointer started inside the canvas and is now outside\n\t\t\t\tif (!fromDoc && !onCanvas) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype = (fromDoc && e.type === \"mouseover\") ? \"mousemove\" : e.type;\n\n\t\t\t\tif (!fromDoc) {\n\t\t\t\t\tthis.canvasHovered = true;\n\t\t\t\t}\n\n\t\t\t\tif (type === \"mousedown\") {\n\t\t\t\t\tthis.canvasUpEventTriggered = false;\n\t\t\t\t\tthis.canvasFocused = true;\n\t\t\t\t\tthis.buttonState = \"down\";\n\t\t\t\t}\n\t\t\t\tif (type === \"mouseup\") {\n\t\t\t\t\tthis.buttonState = \"up\";\n\t\t\t\t}\n\n\t\t\t\t// Get the front object for pointer position, among all added objects\n\t\t\t\tfrontObject = (fromDoc || !onCanvas) ? undefined : events.getFrontObject(\"mouse\");\n\n\t\t\t\t// Trigger events\n\t\t\t\tif (fromDoc && events.frontObject) {\n\t\t\t\t\tevents.triggerChain(events.getParentChain(events.frontObject, true, true), [\"mouseleave\"]);\n\t\t\t\t\tevents.frontObject = null;\n\t\t\t\t} else if (fromDoc) {\n\t\t\t\t\tevents.triggerHandlers(this.core.canvasElement, [\"mouseleave\"]);\n\t\t\t\t} else {\n\t\t\t\t\tevents.triggerPointerEvent(this.types[type], frontObject, \"mouse\", e);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdocHandler: function (e) {\n\t\t\t\tvar onCanvas = this.onCanvas(e);\n\n\t\t\t\tif (!onCanvas) {\n\n\t\t\t\t\tif (this.core.canvasElement.events.hasEntered) {\n\t\t\t\t\t\tif (e.type === \"mouseover\") {\n\t\t\t\t\t\t\tthis.canvasHandler(e, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (e.type === \"mouseup\") {\n\t\t\t\t\t\t\tif (this.buttonState === \"down\") {\n\t\t\t\t\t\t\t\tthis.canvasHandler(e, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e.type === \"mousedown\") {\n\t\t\t\t\t\t\tthis.canvasFocused = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\tgetPos: function (e) {\n\t\t\t\tvar canvas = this.core.canvasElement;\n\t\t\t\tvar boundingRect = canvas.getBoundingClientRect();\n\t\t\t\tvar scaleX = canvas.width / canvas.clientWidth;\n\t\t\t\tvar scaleY = canvas.height / canvas.clientHeight;\n\n\t\t\t\t// Calculate the mouse position relative to the viewport.\n\t\t\t\t// e.clientX exists, but has been incorrect in older versions of webkit.\n\t\t\t\tvar clientX = e.pageX - window.pageXOffset;\n\t\t\t\tvar clientY = e.pageY - window.pageYOffset;\n\n\t\t\t\tvar x = scaleX * (clientX - Math.round(boundingRect.left));\n\t\t\t\tvar y = scaleY * (clientY - Math.round(boundingRect.top));\n\n\t\t\t\treturn { x: x, y: y };\n\t\t\t},\n\n\t\t\tupdatePos: function (e) {\n\t\t\t\tvar pos = this.getPos(e);\n\t\t\t\tthis.x = pos.x;\n\t\t\t\tthis.y = pos.y;\n\t\t\t},\n\t\t\t\n\t\t\tonCanvas: function (e) {\n\t\t\t\te = e || (this.core.events.lastPointerEventObject && this.core.events.lastPointerEventObject.originalEvent);\n\t\t\t\t\n\t\t\t\t// Get pointer position\n\t\t\t\tvar pos = e ? this.getPos(e) : { x: this.x, y: this.y };\n\t\t\t\t\n\t\t\t\t// Check boundaries => (left) && (right) && (top) && (bottom)\n\t\t\t\tif ( (pos.x >= 0) && (pos.x <= this.core.width) && (pos.y >= 0) && (pos.y <= this.core.height) ) {\n\t\t\t\t\tthis.canvasHovered = true;\n\t\t\t\t\tif (e) this.updatePos(e);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.canvasHovered = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcancel: function () {\n\t\t\t\tthis.core.events.lastDownObject = null;\n\t\t\t},\n\n\t\t\thide: function () {\n\t\t\t\tthis.core.canvasElement.style.cursor = \"none\";\n\t\t\t},\n\n\t\t\tshow: function () {\n\t\t\t\tthis.core.canvasElement.style.cursor = this.cursorValue;\n\t\t\t},\n\n\t\t\tcursor: function (value) {\n\t\t\t\tif (~value.indexOf(\"url(\")) {\n\t\t\t\t\tvar m = /url\\((.*?)\\)(\\s(.*?)\\s(.*?)|)($|,.*?$)/.exec(value),\n\t\t\t\t\t\toptions = m[5] ? m[5] : \"\";\n\t\t\t\t\tvalue = \"url(\" + m[1] + \") \" + (m[3] ? m[3] : 0) + \" \" + (m[4] ? m[4] : 0) + (options !== \"\" ? options :  \", default\");\n\t\t\t\t}\n\t\t\t\tthis.core.canvasElement.style.cursor = value;\n\t\t\t\tthis.cursorValue = value;\n\t\t\t}\n\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"mouse\", mouse, \"init\");\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/mouse.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/scenes.js":
/*!********************************************!*\
  !*** ./node_modules/ocanvas/src/scenes.js ***!
  \********************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar scenes = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\t\t\t\n\t\t\t// Set properties\n\t\t\tcurrent: \"none\",\n\t\t\tscenes: {},\n\n\t\t\t// Method for creating a new scene\n\t\t\tcreate: function (name, init) {\n\t\t\t\tthis.scenes[name] = Object.create(this.scenesBase());\n\t\t\t\tthis.scenes[name].name = name;\n\t\t\t\t\n\t\t\t\tinit.call(this.scenes[name]);\n\t\t\t\t\n\t\t\t\treturn this.scenes[name];\n\t\t\t},\n\t\t\t\n\t\t\t// Object base that will be instantiated for each new scene\n\t\t\tscenesBase: function () {\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tname: \"\",\n\t\t\t\t\n\t\t\t\t\t// Container for all objects that are added to the scene\n\t\t\t\t\tobjects: [],\n\t\t\t\t\t\n\t\t\t\t\tloaded: false,\n\t\t\t\t\t\n\t\t\t\t\t// Method for adding objects to the scene\n\t\t\t\t\tadd: function (obj) {\n\t\t\t\t\t\tthis.objects.push(obj);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add the object to canvas if the scene is loaded\n\t\t\t\t\t\tif (this.loaded) {\n\t\t\t\t\t\t\tobj.add();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\n\t\t\t\t\t// Method for removing an object from the scene\n\t\t\t\t\tremove: function (obj) {\n\t\t\t\t\t\tvar index = this.objects.indexOf(obj);\n\t\t\t\t\t\tif (~index) {\n\t\t\t\t\t\t\tthis.objects.splice(index, 1);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Remove the object from canvas if the scene is loaded\n\t\t\t\t\t\t\tif (this.loaded) {\n\t\t\t\t\t\t\t\tobj.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\n\t\t\t\t\t// Method for loading the scene's objects\n\t\t\t\t\tload: function () {\n\t\t\t\t\t\tif (this.loaded) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar objects = this.objects,\n\t\t\t\t\t\t\ti, l = objects.length;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t// Loop through all added objects\n\t\t\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\t\t\tif (objects[i] !== undefined) {\n\t\t\t\t\t\t\t\tobjects[i].add(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.loaded = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\n\t\t\t\t\t// Method for unloading the scene (removes all added objects from the canvas)\n\t\t\t\t\tunload: function () {\n\t\t\t\t\t\tvar objects = this.objects,\n\t\t\t\t\t\t\ti, l = objects.length;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t// Loop through all added objects\n\t\t\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\t\t\tif (objects[i] !== undefined) {\n\t\t\t\t\t\t\t\t// Remove the object from canvas\n\t\t\t\t\t\t\t\tobjects[i].remove(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.loaded = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Method for loading a specific scene\n\t\t\tload: function (name, unload) {\n\t\t\t\t// Unload last scene if not done already\n\t\t\t\tif (unload === true && this.current !== \"none\") {\n\t\t\t\t\tthis.unload(this.current);\n\t\t\t\t}\n\t\t\t\tthis.current = name;\n\t\t\t\tthis.scenes[name].load();\n\n\t\t\t\tthis.core.draw.redraw();\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for unloading a specific scene\n\t\t\tunload: function (name) {\n\t\t\t\tthis.current = \"none\";\n\t\t\t\tthis.scenes[name].unload();\n\n\t\t\t\tthis.core.draw.redraw();\n\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"scenes\", scenes);\n\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/scenes.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/style.js":
/*!*******************************************!*\
  !*** ./node_modules/ocanvas/src/style.js ***!
  \*******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar style = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\t// Method for converting a stroke to either an object or a string\n\t\t\t// Fixes errors if found\n\t\t\tgetStroke: function (value, return_type) {\n\t\t\t\treturn_type = (return_type === \"string\") ? \"string\" : \"object\";\n\t\t\t\n\t\t\t\t// Convert object to string with default values if unspecified\n\t\t\t\tif (typeof value === \"object\" && return_type === \"string\") {\n\t\t\t\t\tvar val = value;\n\t\t\t\t\tvalue = (typeof val.pos === \"string\") ? val.pos : \"center\";\n\t\t\t\t\tvalue += \" \" + (typeof val.width === \"number\" ? val.width+\"px\" : \"1px\");\n\t\t\t\t\tvalue += \" \" + (typeof val.color === \"string\" ? val.color : \"#000000\");\n\t\t\t\t}\n\n\t\t\t\t// Get stroke components\n\t\t\t\tvar stroke = value.split(\" \");\n\n\t\t\t\t// Handle color values with parentheses, because they can contain spaces,\n\t\t\t\t// that would be split by the line above. The color value needs to be in\n\t\t\t\t// one entry in the stroke array.\n\t\t\t\tvar parenStart, parenEnd;\n\t\t\t\tfor (var i = 0, l = stroke.length; i < l; i++) {\n\t\t\t\t\tif (!parenStart && stroke[i].indexOf(\"(\") > -1) parenStart = i;\n\t\t\t\t\tif (stroke[i].indexOf(\")\") > -1) parenEnd = i;\n\t\t\t\t}\n\t\t\t\tvar color = parenEnd ? stroke.splice(parenStart, parenEnd - parenStart + 1) : undefined;\n\t\t\t\tif (color) stroke.push(color.join(\" \"));\n\t\t\t\n\t\t\t\t// Get stroke settings\n\t\t\t\tvar strokePositions = [\"outside\", \"center\", \"inside\"];\n\t\t\t\tvar fixed_color = '', i, num_splits = stroke.length;\n\t\t\t\tvar strokePos, width, color, only_color;\n\t\t\t\t\n\t\t\t\t// If there are more than 2 splits\n\t\t\t\tif (num_splits >= 3) {\n\t\t\t\t\t\n\t\t\t\t\t// If first split is not a valid stroke position\n\t\t\t\t\tif (!~strokePositions.indexOf(stroke[0])) {\n\t\t\t\t\t\n\t\t\t\t\t\t// Boolean that says if only a color is specified\n\t\t\t\t\t\tonly_color = isNaN(parseInt(stroke[0]));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Loop through all the splits and concatenate the split color values\n\t\t\t\t\t\tfor (i = (only_color ? 0 : 1); i < num_splits; i++) {\n\t\t\t\t\t\t\tfixed_color += stroke[i] + (i === num_splits - 1 ? \" \" : \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the fixed stroke array\n\t\t\t\t\t\tif (only_color) {\n\t\t\t\t\t\t\tstroke = [1, fixed_color];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstroke = [stroke[0], fixed_color];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set number of splits so the if case further down is entered\n\t\t\t\t\t\tnum_splits = 2;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\t// Fix color value\n\t\t\t\t\t\tif (num_splits > 3) {\n\t\t\t\t\t\t\tfor (i = 2; i < num_splits; i++) {\n\t\t\t\t\t\t\t\tfixed_color += stroke[i] + (i === num_splits - 1 ? \" \" : \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstroke = [stroke[0], stroke[1], fixed_color];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the stroke object with correct values\n\t\t\t\t\t\tstroke = {\n\t\t\t\t\t\t\tpos: stroke[0],\n\t\t\t\t\t\t\twidth: parseFloat(stroke[1]),\n\t\t\t\t\t\t\tcolor: stroke[2]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If there are only two splits ( [width, color] )\n\t\t\t\tif (num_splits === 2) {\n\t\t\t\t\t\n\t\t\t\t\t// Set the stroke object\n\t\t\t\t\tstroke = {\n\t\t\t\t\t\tpos: \"center\",\n\t\t\t\t\t\twidth: parseFloat(stroke[0]),\n\t\t\t\t\t\tcolor: stroke[1]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If stroke is still an array (empty stroke value was passed in)\n\t\t\t\tif (stroke.length) {\n\t\t\t\t\tstroke = {\n\t\t\t\t\t\tpos: \"center\",\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\tcolor: \"\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (return_type === \"string\") {\n\t\t\t\t\treturn stroke.pos + \" \" + stroke.width + \"px \" + stroke.color;\n\t\t\t\t}\n\t\t\t\telse if (return_type === \"object\") {\n\t\t\t\t\treturn stroke;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for converting a gradient string to a gradient object\n\t\t\tgetGradient: function (value, x, y, width, height) {\n\n\t\t\t\tif (~value.indexOf(\"linear\")) {\n\t\t\t\t\treturn this.getLinearGradient(value, x, y, width, height);\n\t\t\t\t\t\n\t\t\t\t} else if (~value.indexOf(\"radial\")) {\n\t\t\t\t\treturn this.getRadialGradient(value, x, y, width, height);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\treturn \"transparent\";\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for converting a CSS style linear gradient to a CanvasGradient object\n\t\t\tgetLinearGradient: function (value, x, y, width, height) {\n\t\t\t\tvar gradient,\n\t\t\t\t\targs, pos_parts, pos = [], i, start, sX, sY, eX, eY,\n\t\t\t\t\tpositions = [\"top\", \"bottom\", \"left\", \"right\"],\n\t\t\t\t\tmatchedColor, colorIndex, parenColors = [], colorStops, s;\n\t\t\t\n\t\t\t\t// Get arguments of the linear-gradient function, while preserving color values like hsla() and such\n\t\t\t\targs = /\\((.*)\\)/.exec(value)[1];\n\t\t\t\twhile (matchedColor = /((hsl|hsla|rgb|rgba)\\(.*?\\))/.exec(args)) {\n\t\t\t\t\tcolorIndex = parenColors.push(matchedColor[1]) - 1;\n\t\t\t\t\targs = args.substring(0, matchedColor.index) + \"###\" + colorIndex + \"###\" + args.substring(matchedColor.index + matchedColor[1].length, args.length);\n\t\t\t\t}\n\t\t\t\targs = args.split(\",\");\n\t\t\t\t\n\t\t\t\t// Get position keywords\n\t\t\t\tpos_parts = args[0].split(\" \");\n\t\t\t\t\n\t\t\t\t// If the first keyword is a position, add it\n\t\t\t\tif (~positions.indexOf(pos_parts[0]) || ~pos_parts[0].indexOf(\"deg\")) {\n\t\t\t\t\tpos.push(pos_parts[0]);\n\t\t\t\t}\n\t\t\t\t// If the second keyword is a position, add it\n\t\t\t\tif (pos_parts.length > 1 && ~positions.indexOf(pos_parts[1])) {\n\t\t\t\t\tpos.push(pos_parts[1]);\n\t\t\t\t}\n\t\t\t\t// Add default value if none is specified\n\t\t\t\tif (pos.length === 0) {\n\t\t\t\t\tpos.push(\"top\");\n\t\t\t\t} else {\n\t\t\t\t\tstart = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get coordinates for start and ending points, based on the above position\n\t\t\t\t// Get horizontal, vertical or degree specified coordinates\n\t\t\t\tif (pos.length === 1) {\n\t\t\t\t\tif (pos[0] === \"top\") {\n\t\t\t\t\t\tsX = x + width / 2;\n\t\t\t\t\t\tsY = y;\n\t\t\t\t\t\teX = x + width / 2;\n\t\t\t\t\t\teY = y + height;\n\t\t\t\t\t} else if (pos[0] === \"right\") {\n\t\t\t\t\t\tsX = x + width;\n\t\t\t\t\t\tsY = y + height / 2;\n\t\t\t\t\t\teX = x;\n\t\t\t\t\t\teY = y + height / 2;\n\t\t\t\t\t} else if (pos[0] === \"bottom\") {\n\t\t\t\t\t\tsX = x + width / 2;\n\t\t\t\t\t\tsY = y + height;\n\t\t\t\t\t\teX = x + width / 2;\n\t\t\t\t\t\teY = y;\n\t\t\t\t\t} else if (pos[0] === \"left\") {\n\t\t\t\t\t\tsX = x;\n\t\t\t\t\t\tsY = y + height / 2;\n\t\t\t\t\t\teX = x + width;\n\t\t\t\t\t\teY = y + height / 2;\n\t\t\t\t\t} else if (~pos[0].indexOf(\"deg\")) {\n\t\t\t\t\t\tvar alpha, a, beta, cornerDistance, endDistance, cornerX, cornerY, cY,\n\t\t\t\t\t\t\tpi = Math.PI,\n\t\t\t\t\t\t\tcenterX = x + width / 2,\n\t\t\t\t\t\t\tcenterY = y + height / 2;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Convert the angle to the range 0 - 359 degrees and then convert it to radians\n\t\t\t\t\t\talpha = (parseFloat(pos) % 360) * pi / 180;\n\t\t\t\t\t\ta = alpha;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Upper right corner\n\t\t\t\t\t\tif (alpha >= 0 && alpha < pi / 2) {\n\t\t\t\t\t\t\tcornerX = x + width;\n\t\t\t\t\t\t\tcornerY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Upper left corner\n\t\t\t\t\t\telse if (alpha >= pi / 2 && alpha < pi) {\n\t\t\t\t\t\t\tcY = centerY;\n\t\t\t\t\t\t\tcenterY = centerX;\n\t\t\t\t\t\t\tcornerY = x;\n\t\t\t\t\t\t\tcornerX = cY;\n\t\t\t\t\t\t\tcenterX = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Bottom left corner\n\t\t\t\t\t\telse if (alpha >= pi && alpha < pi * 1.5) {\n\t\t\t\t\t\t\tcY = centerY;\n\t\t\t\t\t\t\tcornerX = centerX;\n\t\t\t\t\t\t\tcenterX = x;\n\t\t\t\t\t\t\tcenterY = y + height;\n\t\t\t\t\t\t\tcornerY = cY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Bottom right corner\n\t\t\t\t\t\telse if (alpha >= pi * 1.5 && alpha < pi * 2) {\n\t\t\t\t\t\t\tcY = centerY;\n\t\t\t\t\t\t\tcenterY = x + width;\n\t\t\t\t\t\t\tcornerY = centerX;\n\t\t\t\t\t\t\tcornerX = y + height;\n\t\t\t\t\t\t\tcenterX = cY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Convert the angle to the range 0 - 89\n\t\t\t\t\t\talpha = alpha % (pi / 2);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get angle between baseline and the line between the corner and the center\n\t\t\t\t\t\tbeta = Math.atan(Math.abs(centerY - cornerY) / Math.abs(cornerX - centerX));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the distance between the corner and the center\n\t\t\t\t\t\tcornerDistance = Math.sqrt(Math.pow(centerY - cornerY, 2) + Math.pow(centerX - cornerX, 2));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the distance between the end point and the center\n\t\t\t\t\t\tendDistance = cornerDistance * Math.cos(beta - (alpha));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get end point and start point\n\t\t\t\t\t\t// Upper right corner\n\t\t\t\t\t\tif (a >= 0 && a < pi / 2) {\n\t\t\t\t\t\t\teX = centerX + endDistance * Math.cos(alpha);\n\t\t\t\t\t\t\teY = centerY - endDistance * Math.sin(alpha);\n\t\t\t\t\t\t\tsX = centerX * 2 - eX;\n\t\t\t\t\t\t\tsY = centerY * 2 - eY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Upper left corner\n\t\t\t\t\t\telse if (a >= pi / 2 && a < pi) {\n\t\t\t\t\t\t\teX = centerY - endDistance * Math.cos(pi / 2 - alpha);\n\t\t\t\t\t\t\teY = cornerX - endDistance * Math.sin(pi / 2 - alpha);\n\t\t\t\t\t\t\tsX = centerY * 2 - eX;\n\t\t\t\t\t\t\tsY = cornerX * 2 - eY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Bottom left corner\n\t\t\t\t\t\telse if (a >= pi && a < pi * 1.5) {\n\t\t\t\t\t\t\teX = cornerX + endDistance * Math.cos(pi - alpha);\n\t\t\t\t\t\t\teY = cornerY + endDistance * Math.sin(pi - alpha);\n\t\t\t\t\t\t\tsX = cornerX * 2 - eX;\n\t\t\t\t\t\t\tsY = cornerY * 2 - eY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Bottom right corner\n\t\t\t\t\t\telse if (a >= pi * 1.5 && a < pi * 2) {\n\t\t\t\t\t\t\teX = cornerY - endDistance * Math.cos(pi * 1.5 - alpha);\n\t\t\t\t\t\t\teY = centerX - endDistance * Math.sin(pi * 1.5 - alpha);\n\t\t\t\t\t\t\tsX = cornerY * 2 - eX;\n\t\t\t\t\t\t\tsY = centerX * 2 - eY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t// Get diagonal coordinates\n\t\t\t\t} else {\n\t\t\t\t\tif (~pos.indexOf(\"top\") && ~pos.indexOf(\"left\")) {\n\t\t\t\t\t\tsX = x;\n\t\t\t\t\t\tsY = y;\n\t\t\t\t\t\teX = x + width;\n\t\t\t\t\t\teY = y + height;\n\t\t\t\t\t} else if (~pos.indexOf(\"top\") && ~pos.indexOf(\"right\")) {\n\t\t\t\t\t\tsX = x + width;\n\t\t\t\t\t\tsY = y;\n\t\t\t\t\t\teX = x;\n\t\t\t\t\t\teY = y + height;\n\t\t\t\t\t} else if (~pos.indexOf(\"bottom\") && ~pos.indexOf(\"left\")) {\n\t\t\t\t\t\tsX = x;\n\t\t\t\t\t\tsY = y + height;\n\t\t\t\t\t\teX = x + width;\n\t\t\t\t\t\teY = y;\n\t\t\t\t\t} else if (~pos.indexOf(\"bottom\") && ~pos.indexOf(\"right\")) {\n\t\t\t\t\t\tsX = x + width;\n\t\t\t\t\t\tsY = y + height;\n\t\t\t\t\t\teX = x;\n\t\t\t\t\t\teY = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Create the gradient object\n\t\t\t\tgradient = this.core.canvas.createLinearGradient(sX, sY, eX, eY);\n\t\t\t\t\n\t\t\t\t// Get the color stops\n\t\t\t\tcolorStops = this.getColorStops(gradient, args.slice(start), parenColors);\n\t\t\t\t\n\t\t\t\t// Add the color stops to the gradient object\n\t\t\t\tfor (s = 0; s < colorStops.length; s++) {\n\t\t\t\t\tgradient.addColorStop(colorStops[s].pos / 100, colorStops[s].color);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Return the gradient object\n\t\t\t\treturn gradient;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for converting a CSS style radial gradient to a CanvasGradient object\n\t\t\tgetRadialGradient: function (value, x, y, width, height) {\n\t\t\t\tvar gradient,\n\t\t\t\t\tbg_position_keywords_x = [\"left\", \"center\", \"right\"],\n\t\t\t\t\tbg_position_keywords_y = [\"top\", \"center\", \"bottom\"],\n\t\t\t\t\tbg_position_sizes_x = { \"left\": x, \"center\": (x + width / 2), \"right\": (x + width) },\n\t\t\t\t\tbg_position_sizes_y = { \"top\": y, \"center\": (y + height / 2), \"bottom\": (y + height) },\n\t\t\t\t\tsizes = [\"closest-side\", \"closest-corner\", \"farthest-side\", \"farthest-corner\", \"contain\", \"cover\"],\n\t\t\t\t\targs, i, l, matchedColor, colorIndex, parenColors = [], colorStops, s,\n\t\t\t\t\tpos_arg, num_pos_args = 0, circles = [{x:undefined,y:undefined,r:0}, {x:undefined,y:undefined,r:undefined}], p, p_key,\n\t\t\t\t\tsize_arg, size, size_set = false;\n\t\t\t\t\n\t\t\t\t// Get arguments of the radial-gradient function, while preserving color values like hsla() and such\n\t\t\t\targs = /\\((.*)\\)/.exec(value)[1];\n\t\t\t\twhile (matchedColor = /((hsl|hsla|rgb|rgba)\\(.*?\\))/.exec(args)) {\n\t\t\t\t\tcolorIndex = parenColors.push(matchedColor[1]) - 1;\n\t\t\t\t\targs = args.substring(0, matchedColor.index) + \"###\" + colorIndex + \"###\" + args.substring(matchedColor.index + matchedColor[1].length, args.length);\n\t\t\t\t}\n\t\t\t\targs = args.split(/\\s*,\\s*/);\n\t\t\t\tl = args.length;\n\t\t\t\t\n\t\t\t\t// Get position for start and end circles\n\t\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t\t\n\t\t\t\t\t// If the argument has two values\n\t\t\t\t\tif (~args[i].indexOf(\" \")) {\n\t\t\t\t\t\tpos_arg = args[i].split(\" \");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the different keywords\n\t\t\t\t\t\t// Center\n\t\t\t\t\t\tif (pos_arg[0] === \"center\") {\n\t\t\t\t\t\t\tcircles[i].x = pos_arg[0];\n\t\t\t\t\t\t\tcircles[i].y = pos_arg[1];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Interpret X position for first value of the argument\n\t\t\t\t\t\telse if (~bg_position_keywords_x.indexOf(pos_arg[0])) {\n\t\t\t\t\t\t\tcircles[i].x = pos_arg[0];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Interpret Y position for second value of the argument\n\t\t\t\t\t\t\tif (~bg_position_keywords_y.indexOf(pos_arg[1])) {\n\t\t\t\t\t\t\t\tcircles[i].y = pos_arg[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Interpret Y position for first value of the argument\n\t\t\t\t\t\telse if (~bg_position_keywords_y.indexOf(pos_arg[0])) {\n\t\t\t\t\t\t\tcircles[i].y = pos_arg[0];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Interpret Y position for second value of the argument\n\t\t\t\t\t\t\tif (~bg_position_keywords_x.indexOf(pos_arg[1])) {\n\t\t\t\t\t\t\t\tcircles[i].x = pos_arg[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Interpret X position for first value of the argument and the value is numeric\n\t\t\t\t\t\telse if (!isNaN(parseFloat(pos_arg[0]))) {\n\t\t\t\t\t\t\tcircles[i].x = pos_arg[0];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Interpret Y position for second value of the argument (could be either keyword or numeric)\n\t\t\t\t\t\t\tif (~bg_position_keywords_y.indexOf(pos_arg[1]) || !isNaN(parseFloat(pos_arg[1]))) {\n\t\t\t\t\t\t\t\tcircles[i].y = pos_arg[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add the missing position values\n\t\t\t\t\t\tif (!circles[i].x) {\n\t\t\t\t\t\t\tcircles[i].x = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!circles[i].y) {\n\t\t\t\t\t\t\tcircles[i].y = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If only one value was passed in as the argument\n\t\t\t\t\telse {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add position if it's a keyword for either an X or Y position\n\t\t\t\t\t\tif (~bg_position_keywords_x.indexOf(args[i])) {\n\t\t\t\t\t\t\tcircles[i].x = args[i];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t} else if (~bg_position_keywords_y.indexOf(args[i])) {\n\t\t\t\t\t\t\tcircles[i].y = args[i];\n\t\t\t\t\t\t\tnum_pos_args = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If the position is not a valid keyword and this is the end circle,\n\t\t\t\t\t\t// add the same position as the first circle has\n\t\t\t\t\t\telse if (i === 1) {\n\t\t\t\t\t\t\tcircles[i].x = circles[0].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add default position for the first value if nothing valid was passed in\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcircles[i].x = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Since only one value was passed in, the second must be added here\n\t\t\t\t\t\t// If this is the second position (end circle), use the first circle's position\n\t\t\t\t\t\tif (i === 1) {\n\t\t\t\t\t\t\tcircles[i].y = circles[0].y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add default value if nothing value was passed in\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcircles[i].y = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\t// Get the size\n\t\t\t\t\n\t\t\t\t// Check for keywords\n\t\t\t\tif (~sizes.indexOf(args[num_pos_args])) {\n\t\t\t\t\tsize = args[num_pos_args];\n\t\t\t\t\tsize_set = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check for pixel or percentage value\n\t\t\t\tif (/\\d+(%|px)\\s/.test(args[num_pos_args])) {\n\t\t\t\t\tsize = parseFloat(args[num_pos_args]);\n\t\t\t\t\tsize_set = true;\n\t\t\t\t\tif (isNaN(size)) {\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Defaults if no correct values were passed in\n\t\t\t\tif (size === undefined) {\n\t\t\t\t\tsize = \"cover\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// Convert all positions to actual pixel sizes relative to the top left corner of the canvas\n\t\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t\n\t\t\t\t\t// Get pixel sizes for keywords\n\t\t\t\t\tcircles[i].abs_x = bg_position_sizes_x[circles[i].x];\n\t\t\t\t\tcircles[i].abs_y = bg_position_sizes_y[circles[i].y];\n\t\t\t\t\t\n\t\t\t\t\t// Loop through both x and y\n\t\t\t\t\tfor (p = 0; p < 2; p++) {\n\t\t\t\t\t\n\t\t\t\t\t\tp_key = \"abs_\" + (p === 0 ? \"x\" : \"y\");\n\t\t\t\t\t\n\t\t\t\t\t\t// If the value was not found, it is not a keyword – it is probably a number\n\t\t\t\t\t\tif (circles[i][p_key] === undefined) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Get the number\n\t\t\t\t\t\t\tcircles[i][p_key] = parseFloat(circles[i][(p_key === \"abs_x\" ? \"x\" : \"y\")]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If it was not a number, get the center value\n\t\t\t\t\t\t\tif (isNaN(circles[i][p_key])) {\n\t\t\t\t\t\t\t\tcircles[i][p_key] = (p_key === \"abs_x\") ? bg_position_sizes_x.center - x : bg_position_sizes_y.center - y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If it was a percentage, convert it to an actual pixel size\n\t\t\t\t\t\t\tif (~circles[i][(p_key === \"abs_x\" ? \"x\" : \"y\")].indexOf(\"%\")) {\n\t\t\t\t\t\t\t\tcircles[i][p_key] = (circles[i][p_key] / 100) * (p_key === \"abs_x\" ? width : height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Add the x offset to make the position relative to the left corner of the canvas\n\t\t\t\t\t\t\tcircles[i][p_key] += (p_key === \"abs_x\") ? x : y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// Convert the size to actual pixels\n\t\t\t\t\n\t\t\t\t// Check for keywords\n\t\t\t\tif (~sizes.indexOf(size)) {\n\t\t\t\t\tif (size === \"closest-side\" || size === \"contain\") {\n\t\t\t\t\t\tsize = Math.min(\n\t\t\t\t\t\t\tMath.abs(circles[1].abs_y - y),\n\t\t\t\t\t\t\tMath.abs(y + height - circles[1].abs_y),\n\t\t\t\t\t\t\tMath.abs(circles[1].abs_x - x),\n\t\t\t\t\t\t\tMath.abs(x + width - circles[1].abs_y)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (size === \"closest-corner\") {\n\t\t\t\t\t\tsize = Math.min(\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((circles[1].abs_x - x), 2) + Math.pow((circles[1].abs_y - y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((x + width - circles[1].abs_x), 2) + Math.pow((circles[1].abs_y - y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((x + width - circles[1].abs_x), 2) + Math.pow((y + height - circles[1].abs_y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((circles[1].abs_x - x), 2) + Math.pow((y + height - circles[1].abs_y), 2))\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (size === \"farthest-corner\" || size === \"cover\") {\n\t\t\t\t\t\tsize = Math.max(\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((circles[1].abs_x - x), 2) + Math.pow((circles[1].abs_y - y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((x + width - circles[1].abs_x), 2) + Math.pow((circles[1].abs_y - y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((x + width - circles[1].abs_x), 2) + Math.pow((y + height - circles[1].abs_y), 2)),\n\t\t\t\t\t\t\tMath.sqrt(Math.pow((circles[1].abs_x - x), 2) + Math.pow((y + height - circles[1].abs_y), 2))\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (size === \"farthest-side\") {\n\t\t\t\t\t\tsize = Math.max(\n\t\t\t\t\t\t\tMath.abs(circles[1].abs_y - y),\n\t\t\t\t\t\t\tMath.abs(y + height - circles[1].abs_y),\n\t\t\t\t\t\t\tMath.abs(circles[1].abs_x - x),\n\t\t\t\t\t\t\tMath.abs(x + width - circles[1].abs_y)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check for a percentage\n\t\t\t\tif (~args[num_pos_args].indexOf(\"%\")) {\n\t\t\t\t\t\n\t\t\t\t\t// Convert it to pixels relative to the specified dimension. Defaults to width\n\t\t\t\t\tif (~args[num_pos_args].indexOf(\" \")) {\n\t\t\t\t\t\tsize_arg = args[num_pos_args].split(\" \")[1] === \"height\" ? height : width;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsize_arg = width;\n\t\t\t\t\t}\n\t\t\t\t\tsize = (size / 100) * size_arg;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set the radius for the end circle\n\t\t\t\tcircles[1].r = size;\n\t\t\t\t\n\t\t\t\t// Create the gradient object\n\t\t\t\tgradient = this.core.canvas.createRadialGradient(circles[0].abs_x, circles[0].abs_y, circles[0].r, circles[1].abs_x, circles[1].abs_y, circles[1].r);\n\t\t\t\t\n\t\t\t\t// Get the color stops\n\t\t\t\tcolorStops = this.getColorStops(gradient, args.slice(num_pos_args + (size_set ? 1 : 0)), parenColors);\n\t\t\t\t\n\t\t\t\t// Add the color stops to the gradient object\n\t\t\t\tfor (s = 0; s < colorStops.length; s++) {\n\t\t\t\t\tgradient.addColorStop(colorStops[s].pos / 100, colorStops[s].color);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn gradient;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for getting color stops\n\t\t\tgetColorStops: function (gradient, stops, parenColors) {\n\t\t\t\n\t\t\t\tvar i, l = stops.length,\n\t\t\t\t\tcolorStop, stop_parts, color, color_pos, colorStops = [];\n\t\t\t\n\t\t\t\t// Loop through all color stops\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tcolorStop = stops[i].trim();\n\t\t\t\t\t\n\t\t\t\t\t// If the last position was more than or equal to 100 %,\n\t\t\t\t\t// the following would not be visible anyway, so setting it is unnecessary\n\t\t\t\t\tif (color_pos >= 100) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Split the color stop value to separate the color from the position\n\t\t\t\t\t// Using space is OK, since hsla() values and such are stripped away up at the top\n\t\t\t\t\t// Positions outside the range 0 - 100 % are not supported at the moment\n\t\t\t\t\tif (~colorStop.indexOf(\" \")) {\n\t\t\t\t\t\tstop_parts = colorStop.split(\" \");\n\t\t\t\t\t\tcolor = stop_parts[0];\n\t\t\t\t\t\tcolor_pos = stop_parts[1];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Convert a pixel value to a percentage\n\t\t\t\t\t\tif (~color_pos.indexOf(\"px\")) {\n\t\t\t\t\t\t\tcolor_pos = parseFloat(color_pos) / Math.sqrt(Math.pow(eX - sX, 2) + Math.pow(eY - sY, 2)) * 100;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolor_pos = parseFloat(color_pos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// No position was specified, so one will be generated\n\t\t\t\t\telse {\n\t\t\t\t\t\tcolor = colorStop;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set first position to 0 if not set before\n\t\t\t\t\t\tif (color_pos === undefined) {\n\t\t\t\t\t\t\tcolor_pos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the next position if it's not the first one\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcolor_pos = color_pos || 0;\n\t\t\t\t\t\t\tcolor_pos = color_pos + ((100 - color_pos) / (l - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Get the saved color value if the color contained parentheses when passed in to this method\n\t\t\t\t\tif (~color.indexOf(\"###\")) {\n\t\t\t\t\t\tcolor = parenColors[/###(\\d+)###/.exec(color)[1]];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Add color data to an array with all color stops\n\t\t\t\t\tcolorStops.push({\n\t\t\t\t\t\tpos: color_pos,\n\t\t\t\t\t\tcolor: color\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn colorStops;\n\t\t\t},\n\t\t\t\n\t\t\t// Method for converting a font to either a string or an object\n\t\t\tgetFont: function (value, return_type) {\n\t\t\t\treturn_type = (return_type === \"string\") ? \"string\" : \"object\";\n\t\t\t\t\n\t\t\t\t// Convert object to string with default values if unspecified\n\t\t\t\tif (typeof value === \"object\" && return_type === \"string\") {\n\t\t\t\t\tvar val = value;\n\t\t\t\t\tvalue = (typeof val.style === \"string\" ? val.style : \"normal\");\n\t\t\t\t\tvalue += \" \" + (typeof val.variant === \"string\" ? val.variant : \"normal\");\n\t\t\t\t\tvalue += \" \" + (typeof val.weight === \"string\" ? val.weight : \"normal\");\n\t\t\t\t\tvalue += \" \" + (typeof val.size === \"number\" ? (~~(val.size * 10 + 0.5) / 10)+\"px\" : \"16px\");\n\t\t\t\t\tvalue += \"/\" + (typeof val.lineHeight === \"number\" ? (~~(val.lineHeight * 10 + 0.5) / 10) :\n\t\t\t\t\t\t(typeof val.lineHeight === \"string\" ? (val.lineHeight.indexOf(\"px\") > -1 ? val.lineHeight : 1) : 1));\n\t\t\t\t\tvalue += \" \" + (typeof val.family === \"string\" ? val.family : \"sans-serif\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value.length > 0) {\n\t\t\t\t\n\t\t\t\t\t// Get font settings\n\t\t\t\t\tvar font = value.split(\" \"),\n\t\t\t\t\t\tl = font.length,\n\t\t\t\t\t\ti, value, splits, n, family = \"\",\n\t\t\t\t\t\tstyles = [\"normal\", \"italic\", \"oblique\"],\n\t\t\t\t\t\tvariants = [\"normal\", \"small-caps\"],\n\t\t\t\t\t\tweights = [\"normal\", \"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\"],\n\t\t\t\t\t\tfont_object = {};\n\t\t\t\t\t\n\t\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\t\tvalue = font[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Font style\n\t\t\t\t\t\tif (~styles.indexOf(value) && !font_object.style) {\n\t\t\t\t\t\t\tfont_object.style = value;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t// Font variant\n\t\t\t\t\t\tif (~variants.indexOf(value) && !font_object.variant) {\n\t\t\t\t\t\t\tfont_object.variant = value;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t// Font weight\n\t\t\t\t\t\tif (~weights.indexOf(value) && !font_object.weight) {\n\t\t\t\t\t\t\tfont_object.weight = value;\n\t\t\t\t\t\t} else\n\t\n\t\t\t\t\t\tif (~value.indexOf(\"/\") && !font_object.size && !font_object.lineHeight) {\n\t\t\t\t\t\t\tsplits = value.split(\"/\");\n\t\t\t\t\t\t\t// Font size\n\t\t\t\t\t\t\tif (!isNaN(parseInt(splits[0]))) {\n\t\t\t\t\t\t\t\tfont_object.size = parseInt(splits[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Line height\n\t\t\t\t\t\t\tif (!isNaN(parseFloat(splits[1]))) {\n\t\t\t\t\t\t\t\tfont_object.lineHeight = parseFloat(splits[1]);\n\t\t\t\t\t\t\t\tfont_object.lineHeightUnit = splits[1].indexOf(\"px\") > -1 ? \"px\" : \"relative\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!font_object.size && /\\d+[a-z]{2}(?!\\/)/.test(value)) {\n\t\t\t\t\t\t\t// Font size\n\t\t\t\t\t\t\tif (!isNaN(parseInt(value))) {\n\t\t\t\t\t\t\t\tfont_object.size = parseInt(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Font family\n\t\t\t\t\t\tif (isNaN(parseInt(value)) && !font_object.family) {\n\t\t\t\t\t\t\tfamily = \"\";\n\t\t\t\t\t\t\tfor (n = i; n < l; n++) {\n\t\t\t\t\t\t\t\tfamily += font[n] + (n === l-1 ? \"\" : \" \")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfont_object.family = family;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set default values if unspecified\n\t\t\t\tfont = font_object || {};\n\t\t\t\tfont.style = font.style ? font.style : \"normal\";\n\t\t\t\tfont.variant = font.variant ? font.variant : \"normal\";\n\t\t\t\tfont.weight = font.weight ? font.weight : \"normal\";\n\t\t\t\tfont.size = font.size !== undefined ? font.size : 16;\n\t\t\t\tfont.lineHeight = font.lineHeight !== undefined ? font.lineHeight : 1;\n\t\t\t\tfont.lineHeightUnit = font.lineHeightUnit !== undefined ? font.lineHeightUnit : \"relative\";\n\t\t\t\tfont.family = font.family ? font.family : \"sans-serif\";\n\t\t\t\t\n\t\t\t\tif (return_type === \"string\") {\n\t\t\t\t\treturn font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" +\n\t\t\t\t\t\tfont.lineHeight + (font.lineHeightUnit === \"px\" ? \"px\" : \"\") + \" \" + font.family;\n\t\t\t\t}\n\t\t\t\telse if (return_type === \"object\") {\n\t\t\t\t\treturn font;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for converting a shadow to either an object or a string\n\t\t\tgetShadow: function (value, return_type) {\n\t\t\t\tvar shadow = {}, values;\n\t\t\t\t\n\t\t\t\t// Correct errors if any when an object is passed in\n\t\t\t\tif (typeof value === \"object\") {\n\t\t\t\t\tshadow.offsetX = !isNaN(parseFloat(value.offsetX)) ? parseFloat(value.offsetX) : 0;\n\t\t\t\t\tshadow.offsetY = !isNaN(parseFloat(value.offsetY)) ? parseFloat(value.offsetY) : 0;\n\t\t\t\t\tshadow.blur = !isNaN(parseFloat(value.blur)) ? parseFloat(value.blur) : 0;\n\t\t\t\t\tshadow.color = this.isColor(value.color) ? value.color : \"#000\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Parse the values if a string was passed in\n\t\t\t\telse if (typeof value === \"string\") {\n\t\t\t\t\t\n\t\t\t\t\tvar values = /^(.*?)\\s(.*?)\\s(.*?)\\s(.*?)$/.exec(value);\n\t\t\t\t\tshadow.offsetX = !isNaN(parseFloat(values[1])) ? parseFloat(values[1]) : 0;\n\t\t\t\t\tshadow.offsetY = !isNaN(parseFloat(values[2])) ? parseFloat(values[2]) : 0;\n\t\t\t\t\tshadow.blur = !isNaN(parseFloat(values[3])) ? parseFloat(values[3]) : 0;\n\t\t\t\t\tshadow.color = this.isColor(values[4]) ? values[4] : \"#000\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (return_type === \"string\") {\n\t\t\t\t\treturn shadow.offsetX + \"px \" + shadow.offsetY + \"px \" + shadow.blur + \"px \" + shadow.color;\n\t\t\t\t} else {\n\t\t\t\t\treturn shadow;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t// Method for checking if a value is a color or not\n\t\t\tisColor: function (value) {\n\t\t\t\tif (typeof value === \"string\" && (value[0] === \"#\" || value.substr(0, 4) === \"rgb(\" || value.substr(0, 5) === \"rgba(\" || value.substr(0, 4) === \"hsl(\" || value.substr(0, 5) === \"hsla(\")) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"style\", style);\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/style.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/timeline.js":
/*!**********************************************!*\
  !*** ./node_modules/ocanvas/src/timeline.js ***!
  \**********************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the timeline class\n\tvar timeline = function () {\n\t\n\t\t// Return an object when instantiated\n\t\tvar module = {\n\t\t\t\n\t\t\tinit: function () {\n\t\t\t\tvar _this = this;\n\t\t\t\t\n\t\t\t\t// Method for setting the function to be called for each frame\n\t\t\t\tthis.core.setLoop = function (callback) {\n\t\t\t\t\t_this.userLoop = callback;\n\t\t\t\t\t\n\t\t\t\t\t// Return the timeline object to enable methods like start() to be called directly\n\t\t\t\t\treturn _this;\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Set default values when initialized\n\t\t\tcurrentFrame: 1,\n\t\t\ttimeline: 0,\n\t\t\trunning: false,\n\t\t\t\n\t\t\tset fps (value) {\n\t\t\t\tthis.core.settings.fps = value;\n\t\t\t\t\n\t\t\t\t// Restart the timer if the timeline is running\n\t\t\t\tif (this.running) {\n\t\t\t\t\tthis.start();\n\t\t\t\t}\n\t\t\t},\n\t\t\tget fps () {\n\t\t\t\treturn this.core.settings.fps;\n\t\t\t},\n\t\t\t\n\t\t\t// Method that will be called for each frame\n\t\t\tloop: function () {\n\t\t\t\tif (!this.running) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set up a timer to respect the chosen fps,\n\t\t\t\t// but use RAF to decide when the next call should be made.\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tmodule.timeline = requestAnimationFrame(module.loopBound);\n\n\t\t\t\t\tvar core = module.core;\n\t\t\t\t\n\t\t\t\t\t// If mainLoop has been defined\n\t\t\t\t\tif (typeof module.userLoop === \"function\") {\n\n\t\t\t\t\t\t// Clear the canvas if specified\n\t\t\t\t\t\tif (core.settings.clearEachFrame === true) {\n\t\t\t\t\t\t\tcore.draw.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Trigger the user defined function mainLoop and set this to the current core instance\n\t\t\t\t\t\tmodule.userLoop.call(core, core.canvas);\n\n\t\t\t\t\t\t// Redraw the canvas if specified\n\t\t\t\t\t\tif (core.settings.drawEachFrame === true) {\n\t\t\t\t\t\t\tcore.draw.redraw();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment the frame count\n\t\t\t\t\t\tmodule.currentFrame++;\n\t\t\t\t\t}\n\n\t\t\t\t}, 1000 / module.fps);\n\t\t\t},\n\n\t\t\t// A wrapper function for the loop to bind this keyword\n\t\t\tloopBound: function () {\n\t\t\t\tmodule.loop();\n\t\t\t},\n\t\t\n\t\t\t// Method that starts the timeline\n\t\t\tstart: function () {\n\t\t\t\tcancelAnimationFrame(module.timeline);\n\t\t\t\tmodule.running = true;\n\t\t\t\tmodule.loop();\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t\n\t\t\t// Method that stops the timeline\n\t\t\tstop: function () {\n\t\t\t\tthis.running = false;\n\t\t\t\tcancelAnimationFrame(module.timeline);\n\t\t\t\t\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\n\t\treturn module;\n\t};\n\t\n\t// Register the timeline module\n\toCanvas.registerModule(\"timeline\", timeline, \"init\");\n\t\n})(oCanvas, window, document);\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/timeline.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/tools.js":
/*!*******************************************!*\
  !*** ./node_modules/ocanvas/src/tools.js ***!
  \*******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar tools = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\t\t\t\n\t\t\t// Method for transforming the pointer position to the current object's transformation\n\t\t\ttransformPointerPosition: function (obj, cX, cY, extraAngle, pointer) {\n\t\t\t\textraAngle = extraAngle || 0;\n\t\t\t\tpointer = pointer || this.core.pointer;\n\t\t\t\t\n\t\t\t\t// All calls that come from isPointerInside() will pass the display object as its first argument\n\t\t\t\t// This method will then do multiple transforms for each object in the parent chain to get the correct result\n\t\t\t\tif (typeof obj === \"object\") {\n\t\t\t\t\tvar parent = obj.parent,\n\t\t\t\t\t\tobjectChain = [],\n\t\t\t\t\t\tpos = { x: 0, y: 0 },\n\t\t\t\t\t\tlast, object, n, l, origin;\n\t\t\t\t\t\n\t\t\t\t\t// Get all objects in the parent chain, including this one\n\t\t\t\t\tobjectChain.push(obj);\n\t\t\t\t\twhile (parent && parent !== this.core) {\n\t\t\t\t\t\tobjectChain.push(parent);\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Reverse the array so the top level parent comes first, and ends with the current object\n\t\t\t\t\tobjectChain.reverse();\n\t\t\t\t\t\n\t\t\t\t\t// Loop through all objects in the parent chain\n\t\t\t\t\tlast = pointer;\n\t\t\t\t\tfor (n = 0, l = objectChain.length; n < l; n++) {\n\t\t\t\t\t\tobject = objectChain[n];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If the object has a rotation, get the transformed mouse position for that rotation\n\t\t\t\t\t\tpos = this.transformPointerPosition(object.rotation, object.abs_x, object.abs_y, 0, last);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Save the current position so that the next iteration can use that as the pointer\n\t\t\t\t\t\tlast = pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Rotate an extra angle if specified\n\t\t\t\t\tif (extraAngle !== 0) {\n\t\t\t\t\t\torigin = obj.getOrigin();\n\t\t\t\t\t\tpos = this.transformPointerPosition(extraAngle * -1, cX - origin.x, cY - origin.y, 0, last);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Return the correct position after all transforms\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: pos.x,\n\t\t\t\t\t\ty: pos.y\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If the first argument is not an object, it is the rotation passed in above\n\t\t\t\telse {\n\t\t\t\t\tvar rotation = obj;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar topright = (pointer.x >= cX && pointer.y <= cY),\n\t\t\t\t\tbottomright = (pointer.x >= cX && pointer.y >= cY),\n\t\t\t\t\tbottomleft = (pointer.x <= cX && pointer.y >= cY),\n\t\t\t\t\ttopleft = (pointer.x <= cX && pointer.y <= cY),\n\t\t\t\t\tD = Math.sqrt(Math.pow(pointer.x - cX, 2) + Math.pow(pointer.y - cY, 2)),\n\t\t\t\t\trotation = ((rotation / 360) - Math.floor(rotation / 360)) * 360 - extraAngle,\n\t\t\t\t\tc, x, y,\n\t\t\t\t\tb = (D === 0) ? 0 : Math.abs(pointer.y - cY) / D;\n\t\t\t\t\n\t\t\t\t// When pointer is in top right or bottom left corner\n\t\t\t\tif ( topright || bottomleft ) {\n\t\t\t\t\tc = (180 - rotation - Math.asin(b) * 180 / Math.PI) * Math.PI / 180;\n\t\t\t\t\t\n\t\t\t\t\tx = cX + Math.cos(c) * D * (topright ? -1 : 1);\n\t\t\t\t\ty = cY + Math.sin(c) * D * (topright ? -1 : 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// When pointer is in top left or bottom right corner\n\t\t\t\telse if (topleft || bottomright) {\n\t\t\t\t\tc = (Math.asin(b) * 180 / Math.PI - rotation) * Math.PI / 180;\n\t\t\t\t\t\n\t\t\t\t\tx = cX + Math.cos(c) * D * (topleft ? -1 : 1);\n\t\t\t\t\ty = cY + Math.sin(c) * D * (topleft ? -1 : 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t};\n\t\t\t},\n\t\t\t\n\t\t\t// Method for checking if the pointer's current position is inside the specified object\n\t\t\tisPointerInside: function (obj, pointerObject) {\n\t\t\t\n\t\t\t\tvar origin = obj.getOrigin();\n\t\t\t\n\t\t\t\t// Line\n\t\t\t\tif (obj.type === \"line\") {\n\t\t\t\t\n\t\t\t\t\t// Get angle difference relative to if it had been horizontal\n\t\t\t\t\tvar dX = Math.abs(obj._.end_x - obj.abs_x),\n\t\t\t\t\t\tdY = Math.abs(obj._.end_y - obj.abs_y),\n\t\t\t\t\t\tD = Math.sqrt(dX * dX + dY * dY),\n\t\t\t\t\t\ts = obj.start,\n\t\t\t\t\t\te = obj.end,\n\t\t\t\t\t\tfactor = (s.x < e.x && s.y < e.y) || (s.x > e.x && s.y > e.y) ? -1 : 1,\n\t\t\t\t\t\tangle = Math.asin(dY / D) * (180 / Math.PI) * factor,\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Transform the pointer position with the angle correction\n\t\t\t\t\t\tpointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, angle, pointerObject);\n\t\t\t\t\t\n\t\t\t\t\t// Check if pointer is inside the line\n\t\t\t\t\t// Pointer coordinates are transformed to be compared with a horizontal line\n\t\t\t\t\treturn ((pointer.x > obj.abs_x - D - origin.x) && (pointer.x < obj.abs_x + D - origin.x) && (pointer.y > obj.abs_y - obj.strokeWidth / 2 - origin.y) && (pointer.y < obj.abs_y + obj.strokeWidth / 2 - origin.y));\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Text\n\t\t\t\tif (obj.type === \"text\") {\n\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\tstroke = obj.strokeWidth / 2,\n\t\t\t\t\t\tlines = obj._.lines,\n\t\t\t\t\t\tnumLines = lines.length,\n\t\t\t\t\t\tlineHeight = obj.size * obj.lineHeight,\n\t\t\t\t\t\talign = obj.align,\n\t\t\t\t\t\trtl = this.core.canvasElement.dir === \"rtl\",\n\t\t\t\t\t\tbaselines, i, aligns, left, right, top, bottom, isInside;\n\n\t\t\t\t\tbaselines = {\n\t\t\t\t\t\t\"top\":         obj.size *  0.05,\n\t\t\t\t\t\t\"hanging\":     obj.size * -0.12,\n\t\t\t\t\t\t\"middle\":      obj.size * -0.47,\n\t\t\t\t\t\t\"alphabetic\":  obj.size * -0.78,\n\t\t\t\t\t\t\"ideographic\": obj.size * -0.83,\n\t\t\t\t\t\t\"bottom\":      obj.size * -1.00\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (i = 0; i < numLines; i++) {\n\n\t\t\t\t\t\t// Calculate the different positions for different aligns\n\t\t\t\t\t\taligns = {\n\t\t\t\t\t\t\t\"start\":  rtl ? (obj.width - lines[i].width) : 0,\n\t\t\t\t\t\t\t\"left\":   0,\n\t\t\t\t\t\t\t\"center\": (obj.width - lines[i].width) / 2,\n\t\t\t\t\t\t\t\"end\":    rtl ? 0 : (obj.width - lines[i].width),\n\t\t\t\t\t\t\t\"right\":  (obj.width - lines[i].width)\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Find the left and right edges\n\t\t\t\t\t\tleft = obj.abs_x + aligns[align];\n\t\t\t\t\t\tright = left + lines[i].width;\n\n\t\t\t\t\t\t// Find the top and bottom positions based on the text baseline\n\t\t\t\t\t\ttop = obj.abs_y + (lineHeight * i) + baselines[obj.baseline];\n\t\t\t\t\t\tbottom = top + lineHeight + (numLines > 0 && i < numLines - 1 ? 1 : 0);\n\n\t\t\t\t\t\tisInside = ((pointer.x > left - origin.x - stroke) && (pointer.x < right - origin.x + stroke) && (pointer.y > top - origin.y - stroke) && (pointer.y < bottom - origin.y + stroke));\n\n\t\t\t\t\t\tif (isInside) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Rectangle\n\t\t\t\tif (obj.shapeType === \"rectangular\") {\n\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\tstroke = (obj.strokePosition === \"outside\") ? obj.strokeWidth : ((obj.strokePosition === \"center\") ? obj.strokeWidth / 2 : 0);\n\t\t\t\t\t\n\t\t\t\t\treturn ((pointer.x > obj.abs_x - origin.x - stroke) && (pointer.x < obj.abs_x + obj.width - origin.x + stroke) && (pointer.y > obj.abs_y - origin.y - stroke) && (pointer.y < obj.abs_y + obj.height - origin.y + stroke));\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Circle\n\t\t\t\tif (obj.type === \"ellipse\" && obj.radius_x === obj.radius_y) {\n\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\tD = Math.sqrt(Math.pow(pointer.x - obj.abs_x + origin.x, 2) + Math.pow(pointer.y - obj.abs_y + origin.y, 2));\n\t\t\t\t\treturn (D < obj.radius_x + obj.strokeWidth / 2);\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Ellipse\n\t\t\t\tif (obj.type === \"ellipse\") {\n\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\ta = obj.radius_x + obj.strokeWidth / 2,\n\t\t\t\t\t\tb = obj.radius_y + obj.strokeWidth / 2;\n\t\t\t\t\tpointer.x -= obj.abs_x - origin.x;\n\t\t\t\t\tpointer.y -= obj.abs_y - origin.y;\n\t\t\t\t\t\n\t\t\t\t\treturn ((pointer.x * pointer.x) / (a * a) + (pointer.y * pointer.y) / (b * b) < 1);\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Polygon\n\t\t\t\tif (obj.type === \"polygon\") {\n\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\tradius = obj.radius + obj.strokeWidth / 2,\n\t\t\t\t\t\tlength = obj.sides,\n\t\t\t\t\t\tj = length - 1,\n\t\t\t\t\t\todd = false,\n\t\t\t\t\t\ti, thisPoint, prevPoint;\n\t\t\t\t\t\t\n\t\t\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\t\t\n\t\t\t\t\t\t// Calulate positions for the points\n\t\t\t\t\t\tthisPoint = {\n\t\t\t\t\t\t\tx: (obj.abs_x - origin.x + (radius * Math.cos(i * 2 * Math.PI / length))),\n\t\t\t\t\t\t\ty: (obj.abs_y - origin.y + (radius * Math.sin(i * 2 * Math.PI / length)))\n\t\t\t\t\t\t};\n\t\t\t\t\t\tprevPoint = {\n\t\t\t\t\t\t\tx: (obj.abs_x - origin.x + (radius * Math.cos(j * 2 * Math.PI / length))),\n\t\t\t\t\t\t\ty: (obj.abs_y - origin.y + (radius * Math.sin(j * 2 * Math.PI / length)))\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check how many edges we cross using odd parity\n\t\t\t\t\t\tif ( ((thisPoint.y < pointer.y) && (prevPoint.y >= pointer.y)) || ((prevPoint.y < pointer.y) && (thisPoint.y >= pointer.y)) ) {\n\t\t\t\t\t\t\tif (thisPoint.x + (pointer.y - thisPoint.y) / (prevPoint.y - thisPoint.y) * (prevPoint.x - thisPoint.x) < pointer.x) {\n\t\t\t\t\t\t\t\todd = !odd;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj = i;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn odd;\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Arc\n\t\t\t\t// Filled arcs, stroked arcs, stroked arcs that look like pie chart pieces\n\t\t\t\tif (obj.type === \"arc\") {\n\t\t\t\t\tvar angleDiff = obj.end - obj.start,\n\t\t\t\t\t\tangleRange = (obj.direction === \"clockwise\") ? (angleDiff < 0 ? 360 : 0) + (angleDiff % 360 ? angleDiff % 360 : (angleDiff > 0 ? 360 : 0)) : Math.abs(angleDiff),\n\t\t\t\t\t\textraAngle = (obj.direction === \"clockwise\" ? obj.start * -1 : obj.end * -1),\n\t\t\t\t\t\tpointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, extraAngle, pointerObject),\n\t\t\t\t\t\tD = Math.sqrt(Math.pow(pointer.x - obj.abs_x + origin.x, 2) + Math.pow(pointer.y - obj.abs_y + origin.y, 2)),\n\t\t\t\t\t\tradius = obj.radius,\n\t\t\t\t\t\teP = {},\n\t\t\t\t\t\tp1 = {},\n\t\t\t\t\t\ta, y_, z, angle;\n\t\t\t\t\t\n\t\t\t\t\t// Cancel if the distance between pointer and origin is longer than the radius\n\t\t\t\t\tif ((obj.strokeWidth === 0 && D > radius) || (obj.strokeWidth > 0 && D > radius + obj.strokeWidth / 2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If the arc is made like a pie chart piece\n\t\t\t\t\t// (desired radius is set as stroke width and actual radius is set to half that size)\n\t\t\t\t\tif (radius === obj.strokeWidth / 2 || obj.pieSection) {\n\t\t\t\t\t\tvar strokeWidth = obj.pieSection ? obj.radius : strokeWidth;\n\t\t\t\t\t\n\t\t\t\t\t\tif (angleRange > 180) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar pX, pY, pD, pA;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Calculate the distance between the pointer and origin, to find the angle\n\t\t\t\t\t\t\tpX = Math.abs(obj.abs_x - origin.x - pointer.x),\n\t\t\t\t\t\t\tpY = Math.abs(obj.abs_y - origin.y - pointer.y),\n\t\t\t\t\t\t\tpD = Math.sqrt(pX * pX + pY * pY),\n\t\t\t\t\t\t\tpA = Math.acos(pX / pD) * 180 / Math.PI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pointer.y >= obj.abs_y - origin.y && D <= strokeWidth) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else if (pointer.y < obj.abs_y - origin.y && pointer.x < obj.abs_x - origin.x && pA <= (angleRange - 180)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (angleRange === 180) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Inside if pointer is below the origin\n\t\t\t\t\t\t\tif (pointer.y >= obj.abs_y - origin.y && D <= strokeWidth) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (angleRange < 180) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Rotate the pointer position so that the angle is aligned in the bottom like a U\n\t\t\t\t\t\t\textraAngle = (90 - angleRange / 2 - (obj.direction === \"clockwise\" ? obj.start : obj.end));\n\t\t\t\t\t\t\tpointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, extraAngle, pointerObject);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar d, pX, pY, pD, pA;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Fix the radius for this type of arc\n\t\t\t\t\t\t\tradius *= 2;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Calculate the distance from the origin to the y value of the end points\n\t\t\t\t\t\t\td = Math.cos(angleRange / 2 * Math.PI / 180) * radius;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Calculate the distance between the pointer and origin, to find the angle\n\t\t\t\t\t\t\tpX = Math.abs(obj.abs_x - origin.x - pointer.x)\n\t\t\t\t\t\t\tpY = Math.abs(obj.abs_y - origin.y - pointer.y);\n\t\t\t\t\t\t\tpD = Math.sqrt(pX * pX + pY * pY);\n\t\t\t\t\t\t\tpA = Math.asin(pX / pD) * 180 / Math.PI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pointer.y >= obj.abs_y - origin.y + d) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else if (pointer.y >= obj.abs_y - origin.y && pA <= angleRange / 2) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If it's a normal arc\n\t\t\t\t\telse {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (angleRange > 180) {\n\t\t\t\t\t\t\ta = (360 - angleRange) / 2;\n\t\t\t\t\t\t\ty_ = Math.cos(a * Math.PI / 180) * radius;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\teP.x = obj.abs_x - origin.x + Math.cos(a * Math.PI / 180) * y_;\n\t\t\t\t\t\t\teP.y = obj.abs_y - origin.y - Math.sin(a * Math.PI / 180) * y_;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tz = 180 - 2 * a;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tp1.x = obj.abs_x - origin.x - Math.cos(z * Math.PI / 180) * radius;\n\t\t\t\t\t\t\tp1.y = obj.abs_y - origin.y - Math.sin(z * Math.PI / 180) * radius;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar aRight = 90 - (90 - z) - (90 - a);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pointer.y < eP.y && pointer.x < eP.x) {\n\t\t\t\t\t\t\t\tangle = a - Math.acos(Math.abs(pointer.y - eP.y) / Math.sqrt(Math.pow(pointer.x - eP.x, 2) + Math.pow(pointer.y - eP.y, 2))) * 180 / Math.PI;\n\t\t\t\t\t\t\t} else \n\t\t\t\t\t\t\tif (pointer.y > eP.y && pointer.x >= eP.x) {\n\t\t\t\t\t\t\t\tangle = aRight - Math.acos(Math.abs(pointer.x - eP.x) / Math.sqrt(Math.pow(pointer.x - eP.x, 2) + Math.pow(pointer.y - eP.y, 2))) * 180 / Math.PI;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (pointer.y < obj.abs_y - origin.y && pointer.x >= eP.x) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tangle = -1000000;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((obj.fill === \"\" || obj.fill === \"transparent\") && (obj.strokeWidth > 0) && (D < radius - obj.strokeWidth / 2)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (angle <= 0 && pointer.x >= p1.x && pointer.y > eP.y && pointer.y < obj.abs_y - origin.y) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else if (angle <= 0 && pointer.y <= obj.abs_y - origin.y && D <= radius) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else if (((obj.strokeWidth === 0 && D <= radius) || (obj.strokeWidth > 0 && D <= radius + obj.strokeWidth / 2)) && ((pointer.x <= p1.x && pointer.y <= obj.abs_y - origin.y) || (pointer.y >= obj.abs_y - origin.y)) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (angleRange === 180) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Inside if pointer is below the origin\n\t\t\t\t\t\t\tif (pointer.y >= obj.abs_y - origin.y && ((obj.strokeWidth === 0 && D <= radius) || (obj.strokeWidth > 0 && D <= radius + obj.strokeWidth / 2))) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (angleRange < 180) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Rotate the pointer position so that the angle is aligned in the bottom like a U\n\t\t\t\t\t\t\textraAngle = (90 - angleRange / 2 - (obj.direction === \"clockwise\" ? obj.start : obj.end));\n\t\t\t\t\t\t\tpointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, extraAngle, pointerObject);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar r, d;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Make it a bit more accurate when there is only a stroke\n\t\t\t\t\t\t\tr = (obj.fill === \"\") ? radius - obj.strokeWidth / 2 : radius;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Calculate the distance from the origin to the y value of the end points\n\t\t\t\t\t\t\td = Math.cos(angleRange / 2 * Math.PI / 180) * r;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If there is only a stroke\n\t\t\t\t\t\t\tif (obj.fill === \"\" && obj.strokeWidth > 0) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// It has to be lower than the end points, and between the edges of the stroke\n\t\t\t\t\t\t\t\tif (pointer.y >= obj.abs_y - origin.y + d && D >= radius - obj.strokeWidth / 2 && D <= radius + obj.strokeWidth / 2) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If there is a fill and the y position of the pointer is below the end points\n\t\t\t\t\t\t\telse if (pointer.y >= obj.abs_y - origin.y + d) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// If there is also a stroke\n\t\t\t\t\t\t\t\tif (obj.strokeWidth > 0) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// If the distance from origin to pointer is less than to the outer edge of the stroke\n\t\t\t\t\t\t\t\t\tif (D <= radius + obj.strokeWidth / 2) {\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// If no stroke, it is inside\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If the y position of the pointer is above the end points\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\n\t\t\t\t// Generic radial object\n\t\t\t\tif (obj.shapeType === \"radial\") {\n\t\t\t\t\tvar radius = obj.radius ? obj.radius : 0;\n\t\t\t\t\t\n\t\t\t\t\tif (radius > 0) {\n\t\t\t\t\t\tvar pointer = this.transformPointerPosition(obj, obj.abs_x, obj.abs_y, 0, pointerObject),\n\t\t\t\t\t\t\torigin = obj.getOrigin(),\n\t\t\t\t\t\t\tD = Math.sqrt(Math.pow(pointer.x - obj.abs_x + origin.x, 2) + Math.pow(pointer.y - obj.abs_y + origin.y, 2));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\treturn (D < radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"tools\", tools);\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/tools.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/touch.js":
/*!*******************************************!*\
  !*** ./node_modules/ocanvas/src/touch.js ***!
  \*******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Define the class\n\tvar touch = function () {\n\t\t\n\t\t// Return an object when instantiated\n\t\treturn {\n\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\ttouchState: \"up\",\n\t\t\tcanvasFocused: false,\n\t\t\tcanvasHovered: false,\n\t\t\tisTouch: (\"ontouchstart\" in window || \"createTouch\" in document),\n\t\t\tdblTapInterval: 500,\n\n\t\t\tinit: function () {\n\t\t\t\tvar core, canvasElement;\n\n\t\t\t\tcore = this.core;\n\t\t\t\tcanvasElement = core.canvasElement;\n\n\t\t\t\tcore.events.addEventTypes(\"touch\", {\n\t\t\t\t\tmove: \"touchmove\",\n\t\t\t\t\tenter: \"touchenter\",\n\t\t\t\t\tleave: \"touchleave\",\n\t\t\t\t\tdown: \"touchstart\",\n\t\t\t\t\tup: \"touchend\",\n\t\t\t\t\tsingleClick: \"tap\",\n\t\t\t\t\tdoubleClick: \"dbltap\"\n\t\t\t\t});\n\n\t\t\t\tthis.types = {\n\t\t\t\t\t\"touchmove\": \"move\",\n\t\t\t\t\t\"touchstart\": \"down\",\n\t\t\t\t\t\"touchend\": \"up\"\n\t\t\t\t};\n\n\t\t\t\tif (this.isTouch) {\n\t\t\t\t\tcore.pointer = this;\n\t\t\t\t\t\n\t\t\t\t\t// Set iOS specific settings to prevent selection of the canvas element\n\t\t\t\t\tcanvasElement.style.WebkitUserSelect = \"none\";\n\t\t\t\t\tcanvasElement.style.WebkitTouchCallout = \"none\";\n\t\t\t\t\tcanvasElement.style.WebkitTapHighlightColor = \"rgba(0,0,0,0)\";\n\t\t\t\t}\n\n\t\t\t\tthis.bindHandlers();\n\t\t\t},\n\n\t\t\tbindHandlers: function () {\n\t\t\t\tvar self, core, canvasElement, type;\n\t\t\t\t\n\t\t\t\tself = this;\n\t\t\t\tcore = this.core;\n\t\t\t\tcanvasElement = core.canvasElement;\n\n\t\t\t\tfor (type in this.types) {\n\n\t\t\t\t\t// Add event listeners to the canvas element\n\t\t\t\t\toCanvas.addDOMEventHandler(core, canvasElement, type, function (e) {\n\t\t\t\t\t\tself.canvasHandler(e);\n\t\t\t\t\t}, false);\n\n\t\t\t\t\t// Add event listeners to the document (used for setting states and trigger mouseup events)\n\t\t\t\t\toCanvas.addDOMEventHandler(core, document, type, function (e) {\n\t\t\t\t\t\tself.docHandler(e);\n\t\t\t\t\t}, false);\n\n\t\t\t\t\t// We also want to listen to events on the parent document to detect pointer movements\n\t\t\t\t\t// to and from this document.\n\t\t\t\t\t//\n\t\t\t\t\t// Wrap in try...catch in case the documents are of different origins (since that will\n\t\t\t\t\t// throw an exception). This functionality is not strictly needed, but if we can access\n\t\t\t\t\t// the parent document we can provide better pointer event detection between the\n\t\t\t\t\t// documents.\n\t\t\t\t\tvar parentDocument = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparentDocument = window.parent.document;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (parentDocument) {\n\t\t\t\t\t\toCanvas.addDOMEventHandler(core, parentDocument, type, function (e) {\n\t\t\t\t\t\t\tself.docHandler(e);\n\t\t\t\t\t\t}, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add event listener to prevent scrolling on touch devices\n\t\t\t\tif (this.core.settings.disableScrolling) {\n\t\t\t\t\toCanvas.addDOMEventHandler(core, canvasElement, \"touchmove\", function (e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}, false);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcanvasHandler: function (e, fromDoc) {\n\t\t\t\tvar events, onCanvas, frontObject, now, sameObj, interval;\n\n\t\t\t\tevents = this.core.events;\n\t\t\t\tonCanvas = this.onCanvas(e);\n\n\t\t\t\t// Trigger only touchend events if pointer is outside the canvas\n\t\t\t\tif (e.type === \"touchend\" && !onCanvas && !this.canvasUpEventTriggered) {\n\t\t\t\t\tevents.triggerPointerEvent(this.types[\"touchend\"], events.frontObject, \"touch\", e);\n\t\t\t\t\tevents.triggerPointerEvent(this.types[\"touchend\"], this.core.canvasElement, \"touch\", e);\n\t\t\t\t\tthis.canvasUpEventTriggered = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Abort the handler if the pointer started inside the canvas and is now outside\n\t\t\t\tif (!fromDoc && !onCanvas) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!fromDoc) {\n\t\t\t\t\tthis.canvasHovered = true;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === \"touchstart\") {\n\t\t\t\t\tthis.canvasUpEventTriggered = false;\n\t\t\t\t\tthis.canvasFocused = true;\n\t\t\t\t\tthis.touchState = \"down\";\n\t\t\t\t}\n\t\t\t\tif (e.type === \"touchend\") {\n\t\t\t\t\tthis.touchState = \"up\";\n\t\t\t\t}\n\n\t\t\t\t// Get the front object for pointer position, among all added objects\n\t\t\t\tfrontObject = (fromDoc || !onCanvas) ? undefined : events.getFrontObject(\"touch\");\n\n\t\t\t\t// Trigger events\n\t\t\t\tif (fromDoc && events.frontObject) {\n\t\t\t\t\tevents.triggerChain(events.getParentChain(events.frontObject, true, true), [\"touchleave\"]);\n\t\t\t\t\tevents.frontObject = null;\n\t\t\t\t} else if (fromDoc) {\n\t\t\t\t\tevents.triggerHandlers(this.core.canvasElement, [\"touchleave\"]);\n\t\t\t\t} else {\n\t\t\t\t\tevents.triggerPointerEvent(this.types[e.type], frontObject, \"touch\", e);\n\t\t\t\t}\n\n\t\t\t\t// Log timestamps for events, to enable double taps\n\t\t\t\tif (e.type === \"touchstart\") {\n\t\t\t\t\tnow = (new Date()).getTime();\n\n\t\t\t\t\tif (!this.dblTapStart || now - this.dblTapStart.timestamp > this.dblTapInterval) {\n\t\t\t\t\t\tthis.dblTapStart = {\n\t\t\t\t\t\t\ttimestamp: now,\n\t\t\t\t\t\t\tobj: frontObject,\n\t\t\t\t\t\t\tcount: 1\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.dblTapStart.count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e.type === \"touchend\" && this.dblTapStart.count === 2) {\n\t\t\t\t\tnow = (new Date()).getTime();\n\t\t\t\t\tsameObj = frontObject === this.dblTapStart.obj;\n\t\t\t\t\tinterval = now - this.dblTapStart.timestamp;\n\n\t\t\t\t\t// If the second touchend event is on the same object as the first touchstart,\n\t\t\t\t\t//  and the time interval between the events is small enough,\n\t\t\t\t\t//  then trigger a double tap event\n\t\t\t\t\tif (sameObj && interval < this.dblTapInterval) {\n\t\t\t\t\t\tevents.triggerPointerEvent(\"doubleClick\", frontObject, \"touch\", e);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete this.dblTapStart;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdocHandler: function (e) {\n\t\t\t\tvar onCanvas = this.onCanvas(e);\n\n\t\t\t\tif (!onCanvas) {\n\n\t\t\t\t\tif (this.core.canvasElement.events.hasEntered) {\n\t\t\t\t\t\tif (e.type === \"touchmove\") {\n\t\t\t\t\t\t\tthis.canvasHandler(e, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (e.type === \"touchend\") {\n\t\t\t\t\t\t\tif (this.touchState === \"down\") {\n\t\t\t\t\t\t\t\tthis.canvasHandler(e, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e.type === \"touchstart\") {\n\t\t\t\t\t\t\tthis.canvasFocused = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\tgetPos: function (e) {\n\t\t\t\tvar x, y;\n\n\t\t\t\tvar touches = e.changedTouches;\n\t\t\t\t\n\t\t\t\tif (touches !== undefined && touches.length > 0) {\n\t\t\t\t\te = touches[0];\n\t\t\t\t\tvar canvas = this.core.canvasElement;\n\t\t\t\t\tvar boundingRect = canvas.getBoundingClientRect();\n\t\t\t\t\tvar scaleX = canvas.width / canvas.clientWidth;\n\t\t\t\t\tvar scaleY = canvas.height / canvas.clientHeight;\n\n\t\t\t\t\t// Calculate the touch position relative to the viewport.\n\t\t\t\t\t// e.clientX exists, but has been incorrect in older versions of webkit.\n\t\t\t\t\tvar clientX = e.pageX - window.pageXOffset;\n\t\t\t\t\tvar clientY = e.pageY - window.pageYOffset;\n\n\t\t\t\t\tx = scaleX * (clientX - Math.round(boundingRect.left));\n\t\t\t\t\ty = scaleY * (clientY - Math.round(boundingRect.top));\n\n\t\t\t\t} else {\n\t\t\t\t\tx = this.x;\n\t\t\t\t\ty = this.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn { x: x, y: y };\n\t\t\t},\n\n\t\t\tupdatePos: function (e) {\n\t\t\t\tvar pos = this.getPos(e);\n\t\t\t\tthis.x = pos.x;\n\t\t\t\tthis.y = pos.y;\n\t\t\t},\n\t\t\t\n\t\t\tonCanvas: function (e) {\n\t\t\t\te = e || (this.core.events.lastPointerEventObject && this.core.events.lastPointerEventObject.originalEvent);\n\t\t\t\t\n\t\t\t\t// Get pointer position\n\t\t\t\tvar pos = e ? this.getPos(e) : { x: this.x, y: this.y };\n\t\t\t\t\n\t\t\t\t// Check boundaries => (left) && (right) && (top) && (bottom)\n\t\t\t\tif ( (pos.x >= 0) && (pos.x <= this.core.width) && (pos.y >= 0) && (pos.y <= this.core.height) ) {\n\t\t\t\t\tthis.canvasHovered = true;\n\t\t\t\t\tif (e) this.updatePos(e);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.canvasHovered = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcancel: function () {\n\t\t\t\tthis.core.events.lastDownObject = null;\n\t\t\t}\n\n\t\t};\n\t};\n\n\t// Register the module\n\toCanvas.registerModule(\"touch\", touch, \"init\");\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/touch.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/ocanvas/src/utils.js ***!
  \*******************************************/
/***/ (() => {

eval("(function(oCanvas, window, document, undefined){\n\n\t// Extend an object with new properties and replace values for existing properties\n\toCanvas.extend = function () {\n\t\n\t\t// Get first two args\n\t\tvar args = Array.prototype.slice.call(arguments),\n\t\t\tlast = args[args.length - 1],\n\t\t\tdestination = args.splice(0, 1)[0],\n\t\t\tcurrent = args.splice(0, 1)[0],\n\t\t\tx, exclude = [],\n\t\t\tdescriptor;\n\t\t\n\t\t// If the last object is an exclude object, get the properties\n\t\tif (last.exclude && (JSON.stringify(last) === JSON.stringify({exclude:last.exclude}))) {\n\t\t\texclude = last.exclude;\n\t\t}\n\t\t\n\t\t// Do the loop unless this object is an exclude object\n\t\tif (current !== last || exclude.length === 0) {\n\t\t\t\n\t\t\t// Add members from second object to the first\n\t\t\tfor (x in current) {\n\t\t\t\n\t\t\t\t// Exclude specified properties\n\t\t\t\tif (~exclude.indexOf(x)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(current, x);\n\t\t\t\t\n\t\t\t\tif (descriptor.get || descriptor.set) {\n\t\t\t\t\tObject.defineProperty(destination, x, descriptor);\n\t\t\t\t} else {\n\t\t\t\t\tdestination[x] = current[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are more objects passed in, run once more, otherwise return the first object\n\t\tif (args.length > 0) {\n\t\t\treturn oCanvas.extend.apply(this, [destination].concat(args));\n\t\t} else {\n\t\t\treturn destination;\n\t\t}\n\t};\n\n\toCanvas.addDOMEventHandler = function (core, domObject, eventName, handler, useCapture) {\n\t\tcore.domEventHandlers.push({\n\t\t\tobj: domObject,\n\t\t\tevent: eventName,\n\t\t\thandler: handler,\n\t\t\tuseCapture: !!useCapture\n\t\t});\n\t\tdomObject.addEventListener(eventName, handler, useCapture);\n\t};\n\n\toCanvas.removeDOMEventHandler = function (core, index) {\n\t\tvar data = core.domEventHandlers[index];\n\t\tdata.obj.removeEventListener(data.event, data.handler, data.useCapture);\n\t};\n\n\toCanvas.isNumber = function (n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\n\t// Define Object.create if not available\n\tif (typeof Object.create !== \"function\") {\n\t\tObject.create = function (o) {\n\t\t\tfunction F() {}\n\t\t\tF.prototype = o;\n\t\t\treturn new F();\n\t\t};\n\t}\n\n\t// Define Object.getPropertyDescriptor if not available.\n\t// This function will check for the descriptor in the whole prototype chain.\n\tif (typeof Object.getPropertyDescriptor !== \"function\") {\n\t\tObject.getPropertyDescriptor = function(object, property) {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(object, property);\n\t\t\tvar proto = Object.getPrototypeOf(object);\n\t\t\twhile (descriptor === undefined && proto !== null) {\n\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(proto, property);\n\t\t\t\tproto = Object.getPrototypeOf(proto);\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t};\n\t}\n\n\t// requestAnimationFrame polyfill by Erik Möller\n\t// fixes from Paul Irish and Tino Zijdel\n\t// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\t(function () {\n\t\tvar lastTime = 0;\n\t\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\tfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t\t\twindow.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t\t\twindow.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']\n\t\t\t  || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t\t}\n\n\t\tif (!window.requestAnimationFrame) {\n\t\t\twindow.requestAnimationFrame = function (callback, element) {\n\t\t\t\tvar currTime = new Date().getTime();\n\t\t\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\t\tvar id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall);\n\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\treturn id;\n\t\t\t};\n\t\t}\n\n\t\tif (!window.cancelAnimationFrame) {\n\t\t\twindow.cancelAnimationFrame = function (id) {\n\t\t\t\tclearTimeout(id);\n\t\t\t};\n\t\t}\n\t}());\n\n\t// usage: log('inside coolFunc',this,arguments);\n\t// http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/\n\twindow.log = function () {\n\t\tlog.history = log.history || [];\t// store logs to an array for reference\n\t\tlog.history.push(arguments);\n\t\tif (this.console) {\n\t\t\tvar i, args = Array.prototype.slice.call(arguments), l = args.length;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tconsole.log(args[i]);\n\t\t\t}\n\t\t}\n\t};\n\n})(oCanvas, window, document);\n\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/utils.js?");

/***/ }),

/***/ "./node_modules/ocanvas/src/xccessors.js":
/*!***********************************************!*\
  !*** ./node_modules/ocanvas/src/xccessors.js ***!
  \***********************************************/
/***/ (() => {

eval("/*\n * Xccessors Standard: Cross-browser ECMAScript 5 accessors\n * http://purl.eligrey.com/github/Xccessors\n * \n * 2010-06-21\n * By Eli Grey, http://eligrey.com\n * \n * A shim that partially implements Object.defineProperty,\n * Object.getOwnPropertyDescriptor, and Object.defineProperties in browsers that have\n * legacy __(define|lookup)[GS]etter__ support.\n * \n * Licensed under the X11/MIT License\n * Copyright © 2010 Elijah Grey, who also goes by Eli Grey.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n(function () {\n\t\"use strict\";\n\tvar ObjectProto = Object.prototype,\n\tdefineGetter = ObjectProto.__defineGetter__,\n\tdefineSetter = ObjectProto.__defineSetter__,\n\tlookupGetter = ObjectProto.__lookupGetter__,\n\tlookupSetter = ObjectProto.__lookupSetter__,\n\thasOwnProp = ObjectProto.hasOwnProperty;\n\t\n\tif (defineGetter && defineSetter && lookupGetter && lookupSetter) {\n\n\t\tif (!Object.defineProperty) {\n\t\t\tObject.defineProperty = function (obj, prop, descriptor) {\n\t\t\t\tif (arguments.length < 3) { // all arguments required\n\t\t\t\t\tthrow new TypeError(\"Arguments not optional\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprop += \"\"; // convert prop to string\n\n\t\t\t\tif (hasOwnProp.call(descriptor, \"value\")) {\n\t\t\t\t\tif (!lookupGetter.call(obj, prop) && !lookupSetter.call(obj, prop)) {\n\t\t\t\t\t\t// data property defined and no pre-existing accessors\n\t\t\t\t\t\tobj[prop] = descriptor.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((hasOwnProp.call(descriptor, \"get\") ||\n\t\t\t\t\t     hasOwnProp.call(descriptor, \"set\"))) \n\t\t\t\t\t{\n\t\t\t\t\t\t// descriptor has a value prop but accessor already exists\n\t\t\t\t\t\tthrow new TypeError(\"Cannot specify an accessor and a value\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (descriptor.get) {\n\t\t\t\t\tdefineGetter.call(obj, prop, descriptor.get);\n\t\t\t\t}\n\t\t\t\tif (descriptor.set) {\n\t\t\t\t\tdefineSetter.call(obj, prop, descriptor.set);\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\n\t\tif (!Object.getOwnPropertyDescriptor) {\n\t\t\tObject.getOwnPropertyDescriptor = function (obj, prop) {\n\t\t\t\tif (arguments.length < 2) { // all arguments required\n\t\t\t\t\tthrow new TypeError(\"Arguments not optional.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprop += \"\"; // convert prop to string\n\n\t\t\t\tvar descriptor = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable  : true,\n\t\t\t\t\twritable    : true\n\t\t\t\t},\n\t\t\t\tgetter = lookupGetter.call(obj, prop),\n\t\t\t\tsetter = lookupSetter.call(obj, prop);\n\n\t\t\t\tif (!hasOwnProp.call(obj, prop)) {\n\t\t\t\t\t// property doesn't exist or is inherited\n\t\t\t\t\treturn descriptor;\n\t\t\t\t}\n\t\t\t\tif (!getter && !setter) { // not an accessor so return prop\n\t\t\t\t\tdescriptor.value = obj[prop];\n\t\t\t\t\treturn descriptor;\n\t\t\t\t}\n\n\t\t\t\t// there is an accessor, remove descriptor.writable;\n\t\t\t\t// populate descriptor.get and descriptor.set (IE's behavior)\n\t\t\t\tdelete descriptor.writable;\n\t\t\t\tdescriptor.get = descriptor.set = undefined;\n\t\t\t\t\n\t\t\t\tif (getter) {\n\t\t\t\t\tdescriptor.get = getter;\n\t\t\t\t}\n\t\t\t\tif (setter) {\n\t\t\t\t\tdescriptor.set = setter;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn descriptor;\n\t\t\t};\n\t\t}\n\n\t\tif (!Object.defineProperties) {\n\t\t\tObject.defineProperties = function (obj, props) {\n\t\t\t\tfor (var prop in props) {\n\t\t\t\t\tif (hasOwnProp.call(props, prop)) {\n\t\t\t\t\t\tObject.defineProperty(obj, prop, props[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t}\n}());\n\n//# sourceURL=webpack://pacman/./node_modules/ocanvas/src/xccessors.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/ghosts/Blinky.js":
/*!**************************************************!*\
  !*** ./src/bin/classes/dynamic/ghosts/Blinky.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ghost = __webpack_require__(/*! ./Ghost */ \"./src/bin/classes/dynamic/ghosts/Ghost.js\");\n\nmodule.exports = class Blinky extends Ghost{\n  constructor(options) {\n    super(options);\n    this.colors = 'FF0000';\n    this.direction = 'west';\n    this.entID = 'ghost_blinky';\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/ghosts/Blinky.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/ghosts/Clyde.js":
/*!*************************************************!*\
  !*** ./src/bin/classes/dynamic/ghosts/Clyde.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ghost = __webpack_require__(/*! ./Ghost */ \"./src/bin/classes/dynamic/ghosts/Ghost.js\");\n\nmodule.exports = class Clyde extends Ghost{\n  constructor(options) {\n    super(options);\n    this.colors = 'FFB851';\n    this.direction = 'down';\n    this.entID = 'ghost_clyde';\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/ghosts/Clyde.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/ghosts/Ghost.js":
/*!*************************************************!*\
  !*** ./src/bin/classes/dynamic/ghosts/Ghost.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ../../entity */ \"./src/bin/classes/entity.js\");\n\nmodule.exports = class Ghost extends Entity {\n  constructor(options) {\n    super(options);\n    this.pathable = true;\n    this.speed = options.speed || 1;\n    this.colors = '1E1E1E';\n    this.direction = 'east';\n    this.entID = 'ghost_default';\n    this.offsetx = -100;\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/ghosts/Ghost.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/ghosts/Inky.js":
/*!************************************************!*\
  !*** ./src/bin/classes/dynamic/ghosts/Inky.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ghost = __webpack_require__(/*! ./Ghost */ \"./src/bin/classes/dynamic/ghosts/Ghost.js\");\n\nmodule.exports = class Inky extends Ghost{\n  constructor(options) {\n    super(options);\n    this.colors = '00FFFFF';\n    this.direction = 'down';\n    this.entID = 'ghost_inky';\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/ghosts/Inky.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/ghosts/Pinky.js":
/*!*************************************************!*\
  !*** ./src/bin/classes/dynamic/ghosts/Pinky.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ghost = __webpack_require__(/*! ./Ghost */ \"./src/bin/classes/dynamic/ghosts/Ghost.js\");\n\nmodule.exports = class Pinky extends Ghost{\n  constructor(options) {\n    super(options);\n    this.colors = 'FFB8FF';\n    this.direction = 'up';\n    this.entID = 'ghost_pinky';\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/ghosts/Pinky.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/items/Pellet.js":
/*!*************************************************!*\
  !*** ./src/bin/classes/dynamic/items/Pellet.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ../../entity */ \"./src/bin/classes/entity.js\");\n\nmodule.exports = class Pellet extends Entity {\n  constructor(options) {\n    super(options);\n    this.pathable = true;\n    this.entID = 'item_pellet';\n  }\n  collect() {\n    console.log('pellet collected!');\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/items/Pellet.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/items/PowerPellet.js":
/*!******************************************************!*\
  !*** ./src/bin/classes/dynamic/items/PowerPellet.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Pellet = __webpack_require__(/*! ./Pellet */ \"./src/bin/classes/dynamic/items/Pellet.js\");\n\nmodule.exports = class PowerPellet extends Pellet {\n  constructor(options) {\n    super(options);\n    this.entID = 'item_powerpellet';\n  }\n  collect() {\n    console.log('POWERPELLET COLLECTED! GET EM BOYS');\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/items/PowerPellet.js?");

/***/ }),

/***/ "./src/bin/classes/dynamic/players/Pacman.js":
/*!***************************************************!*\
  !*** ./src/bin/classes/dynamic/players/Pacman.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ../../entity */ \"./src/bin/classes/entity.js\");\n\nmodule.exports = class Pacman extends Entity {\n  constructor(options) {\n    super(options);\n    this.pathable = true;\n    this.speed = options.speed || 1;\n    this.entID = 'player_pacman';\n    this.offsetx = -100;\n    this.direction = 'none'\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/dynamic/players/Pacman.js?");

/***/ }),

/***/ "./src/bin/classes/entity.js":
/*!***********************************!*\
  !*** ./src/bin/classes/entity.js ***!
  \***********************************/
/***/ ((module) => {

eval("module.exports = class Entity {\n  constructor(options = {}) {\n    if (options.id === undefined) {\n      throw `Entity Spawned without ID!`;\n    }\n\n    this.x = options.x;\n    this.y = options.y;\n    this.offsetx = 0; //-100 exit cell to left, 100 exit cell to right\n    this.offsety = 0; //-100 exit cell to go up, 100 exit cell to go down\n    this.pathable = options.pathable;\n\n    this._renderData = {\n      ready: false,\n      posMult: window.defaultTileSize,\n      pixelHeight: window.defaultTileSize,\n      pixelWidth: window.defaultTileSize,\n      pixelXOffset: 0,\n      pixelYOffset: 0\n    }\n    this.id = options.id;\n  }\n  getPixelData() {\n    return {\n      x: (this.x * this._renderData.posMult + this._renderData.pixelXOffset) + (this._renderData.posMult * (this.offsetx / 100)),\n      y: (this.y * this._renderData.posMult + this._renderData.pixelYOffset) + (this._renderData.posMult * (this.offsety / 100)),\n      width: this._renderData.pixelWidth,\n      height: this._renderData.pixelHeight\n    }\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/entity.js?");

/***/ }),

/***/ "./src/bin/classes/static/GhostGate.js":
/*!*********************************************!*\
  !*** ./src/bin/classes/static/GhostGate.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ../entity */ \"./src/bin/classes/entity.js\");\n\nmodule.exports = class GhostGate extends Entity {\n  constructor(options = {}) {\n    super(options);\n    this.pathable = false;\n    this.hidden = false;\n    this.entID = 'static_ghostgate';\n    this._renderData.pixelHeight = 4;\n    this._renderData.pixelYOffset += this._renderData.posMult/3;\n  }\n  prepDraw(canvas) {\n    let pixeldata = this.getPixelData();\n    this._renderData.render = canvas.display.rectangle({\n      ...pixeldata,\n      fill: '#FFF'\n    });\n    canvas.addChild(this._renderData.render);\n    this._renderData.ready = true;\n  }\n  draw(canvas, frame, cell, player, ghosts = []) {\n\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/static/GhostGate.js?");

/***/ }),

/***/ "./src/bin/classes/static/Wall.js":
/*!****************************************!*\
  !*** ./src/bin/classes/static/Wall.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ../entity */ \"./src/bin/classes/entity.js\");\n\nmodule.exports = class Wall extends Entity {\n  constructor(options = {}) {\n    super(options);\n    this.pathable = false;\n    this.entID = 'static_wall';\n  }\n\n  prepDraw(canvas) {\n    let pixeldata = this.getPixelData();\n    this._renderData.render = canvas.display.rectangle({\n      ...pixeldata,\n      fill: '#000',\n      stroke: 'inside 2px #00f'\n    });\n    canvas.addChild(this._renderData.render);\n    this._renderData.ready = true;\n  }\n\n  draw(canvas, frame, cell, player, ghosts = []) {\n\n  }\n}\n\n//# sourceURL=webpack://pacman/./src/bin/classes/static/Wall.js?");

/***/ }),

/***/ "./src/bin/world/Cell.js":
/*!*******************************!*\
  !*** ./src/bin/world/Cell.js ***!
  \*******************************/
/***/ ((module) => {

eval("class Cell {\n  constructor(objects = []) {\n    this.contents = objects.slice(0);\n  }\n  insert(object) {\n    this.contents.push(object);\n  }\n  remove(object) {\n    /*\n      Removes an object by reference from a cell.\n    */\n    for(let i = 0; i < this.contents.length; i++) {\n      if (this.contents[i] === object) {\n        this.contents.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n  contains(entID) {\n    var results = [];\n    for (let i in this.contents) {\n      if(typeof entID === 'string') {\n        if(this.contents[i].entID === entID) {\n          return this.contents[i];\n        }\n      } else if (entID instanceof RegExp) {\n        if(entID.test(this.contents[i].entID)) {\n          results.push(this.contents[i]);\n        }\n      }\n    }\n    if(entID instanceof RegExp){\n      if(results.length === 0) {\n        return false;\n      }\n      return results;\n    }\n    return false;\n  }\n  listTypes() {\n    var results = [];\n    for(let i in this.contents){\n      results.push(this.contents[i].entID);\n    }\n    return results;\n  }\n}\n\nmodule.exports = Cell;\n\n//# sourceURL=webpack://pacman/./src/bin/world/Cell.js?");

/***/ }),

/***/ "./src/bin/world/board.js":
/*!********************************!*\
  !*** ./src/bin/world/board.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//Entities\nconst Wall = __webpack_require__(/*! ../classes/static/Wall */ \"./src/bin/classes/static/Wall.js\");\nconst Pellet = __webpack_require__(/*! ../classes/dynamic/items/Pellet */ \"./src/bin/classes/dynamic/items/Pellet.js\");\nconst PowerPellet = __webpack_require__(/*! ../classes/dynamic/items/PowerPellet */ \"./src/bin/classes/dynamic/items/PowerPellet.js\");\nconst Pacman = __webpack_require__(/*! ../classes/dynamic/players/Pacman */ \"./src/bin/classes/dynamic/players/Pacman.js\");\nconst Ghost = __webpack_require__(/*! ../classes/dynamic/ghosts/Ghost */ \"./src/bin/classes/dynamic/ghosts/Ghost.js\");\nconst Inky = __webpack_require__(/*! ../classes/dynamic/ghosts/Inky */ \"./src/bin/classes/dynamic/ghosts/Inky.js\");\nconst Pinky = __webpack_require__(/*! ../classes/dynamic/ghosts/Pinky */ \"./src/bin/classes/dynamic/ghosts/Pinky.js\");\nconst Blinky = __webpack_require__(/*! ../classes/dynamic/ghosts/Blinky */ \"./src/bin/classes/dynamic/ghosts/Blinky.js\");\nconst Clyde = __webpack_require__(/*! ../classes/dynamic/ghosts/Clyde */ \"./src/bin/classes/dynamic/ghosts/Clyde.js\");\nconst GhostGate = __webpack_require__(/*! ../classes/static/GhostGate */ \"./src/bin/classes/static/GhostGate.js\");\n\n//World\nconst spawn = __webpack_require__(/*! ./spawner */ \"./src/bin/world/spawner.js\");\nconst Cell = __webpack_require__(/*! ./Cell */ \"./src/bin/world/Cell.js\");\n\nclass Board {\n  constructor() {\n    this.board = [[]];\n    this.player;\n    this.ghosts = [];\n    //w = wall\n    //. = pellet\n    //o = power pellet\n    //_ = nothing\n    //P = Pacman spawn point\n    //b = Blinky\n    //i = Inky\n    //p = Pinky\n    //c = clyde\n    //- = ghostGate\n    this.layout = `wwwwwwwwwwwwwwwwwwwwwwwwwwww\n      w............ww............w\n      w.wwww.wwwww.ww.wwwww.wwww.w\n      wowwww.wwwww.ww.wwwww.wwwwow\n      w.wwww.wwwww.ww.wwwww.wwww.w\n      w..........................w\n      w.wwww.ww.wwwwwwww.ww.wwww.w\n      w.wwww.ww.wwwwwwww.ww.wwww.w\n      w......ww....ww....ww......w\n      wwwwww.wwwww_ww_wwwww.wwwwww\n      _____w.wwwww_ww_wwwww.w_____\n      _____w.ww_____b____ww.w_____\n      _____w.ww_www--www_ww.w_____\n      wwwwww.ww_w______w_ww.wwwwww\n      ______.___w_i_p_cw___.______\n      wwwwww.ww_w______w_ww.wwwwww\n      _____w.ww_wwwwwwww_ww.w_____\n      _____w.ww__________ww.w_____\n      _____w.ww_wwwwwwww_ww.w_____\n      wwwwww.ww_wwwwwwww_ww.wwwwww\n      w............ww............w\n      w.wwww.wwwww.ww.wwwww.wwww.w\n      w.wwww.wwwww.ww.wwwww.wwww.w\n      wo..ww......._P.......ww..ow\n      www.ww.ww.wwwwwwww.ww.ww.www\n      www.ww.ww.wwwwwwww.ww.ww.www\n      w......ww....ww....ww......w\n      w.wwwwwwwwww.ww.wwwwwwwwww.w\n      w.wwwwwwwwww.ww.wwwwwwwwww.w\n      w..........................w\n      wwwwwwwwwwwwwwwwwwwwwwwwwwww`.replace(/ /g, '');\n    if(!/^[w\\.o_Pipbc\\n-]+$/.test(this.layout)) {\n      throw 'INVALID CHARACTER IN BOARD LAYOUT STRING'\n    }\n    this.layoutArr = this.layout.split('\\n');\n\n    this.board = this.layoutArr.map((row) => {\n      return row.split('').map((col) => {\n        return new Cell();\n      })\n    });\n    this.height = this.board.length;\n    this.width = this.board[0].length;\n\n    for(let y = 0; y < this.board.length; y++) {\n      for(let x = 0; x < this.board[0].length; x++) {\n        let g = '';\n        switch (this.layoutArr[y][x]){\n          case 'w':\n            this.board[y][x].insert(spawn(Wall, {x, y}));\n            break;\n          case '.':\n            this.board[y][x].insert(spawn(Pellet, {x, y}));\n            break;\n          case 'o':\n            this.board[y][x].insert(spawn(PowerPellet, {x, y}));\n            break;\n          case '-':\n            this.board[y][x].insert(spawn(GhostGate, {x, y}));\n            break;\n          case 'P':\n            this.player = spawn(Pacman, {x, y});\n            this.board[y][x].insert(this.player);\n            break;\n          case 'i':\n            g = spawn(Inky, {x, y});\n            this.ghosts.push(g);\n            this.board[y][x].insert(g);\n            break;\n          case 'p':\n            g = spawn(Pinky, {x, y});\n            this.ghosts.push(g);\n            this.board[y][x].insert(g);\n            break;\n          case 'b':\n            g = spawn(Blinky, {x, y});\n            this.ghosts.push(g);\n            this.board[y][x].insert(g);\n            break;\n          case 'c':\n            g = spawn(Clyde, {x, y});\n            this.ghosts.push(g);\n            this.board[y][x].insert(g);\n            break;\n        }\n      }\n    }\n  }\n\n  consoleDraw() {\n    for (let i = 0; i < this.height; i++) {\n      var rowstr = ''\n      for (let j = 0; j < this.width; j++) {\n        this.board[i][j].contains('static_wall') ? rowstr += '%%' :\n        this.board[i][j].contains('static_ghostgate') ? rowstr += '--' :\n        this.board[i][j].contains('item_pellet') ? rowstr += ' º' :\n        this.board[i][j].contains('item_powerpellet') ? rowstr += ' ⁕' :\n        this.board[i][j].contains('player_pacman') ? rowstr += '😏' :\n        this.board[i][j].contains(/ghost/) ? rowstr += '👻' :\n          rowstr += '  ';\n      }\n      console.log(rowstr);\n    }\n    console.log();\n    console.log('player: ');\n    console.log(this.player);\n    console.log('ghosts:');\n    console.log(this.ghosts);\n  }\n  entListVerbose() {\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < this.width; j++) {\n        console.log(this.board[i][j].listTypes());\n      }\n    }\n  }\n  getCell(x, y) {\n    return this.board[y][x];\n  }\n}\n\nmodule.exports = Board;\n\n//# sourceURL=webpack://pacman/./src/bin/world/board.js?");

/***/ }),

/***/ "./src/bin/world/spawner.js":
/*!**********************************!*\
  !*** ./src/bin/world/spawner.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ticker = __webpack_require__(/*! ./ticker */ \"./src/bin/world/ticker.js\");\n\nvar spawner = function(spawnTarget, options) {\n  var id = 0;\n  return function(spawnTarget, options) {\n    var x = new spawnTarget({...options, id: id});\n    if (!x.entID) {\n      throw `Object with ID ${id} spawned without entID! ${spawnTarget}`;\n    }\n    id++;\n    ticker.register(x);\n    return x;\n  }\n}\n\nmodule.exports = spawner();\n\n//# sourceURL=webpack://pacman/./src/bin/world/spawner.js?");

/***/ }),

/***/ "./src/bin/world/ticker.js":
/*!*********************************!*\
  !*** ./src/bin/world/ticker.js ***!
  \*********************************/
/***/ ((module) => {

eval("class Ticker {\n  constructor(canvas) {\n    this.entList = [];\n    this.frame = 0;\n    this.tickInterval = Math.floor(1000 / 16);\n    this.intervalDigit = 0;\n    this.ticking = false;\n  }\n  setCanvas(canvas) {\n    this.canvas = canvas;\n  }\n  register(obj) {\n    if (obj.constructor.name.includes('Board')) {\n      this.board = obj;\n    } else {\n      this.entList.push(obj);\n    }\n  }\n  list() {\n    return this.entList;\n  }\n  tick() {\n    //Handle Collisions\n    this.entList.forEach((entity) => {\n      if (!entity.collide) { return }\n      var cell = entity.x && entity.y && this.board ? this.board.getCell(entity.x, entity.y) : undefined;\n      entity.collide(this.frame, cell, this.board.player, this.board.ghosts);\n    });\n    //Handle ticks\n    this.entList.forEach((entity) => {\n      if (!entity.tick) { return }\n      var cell = entity.x && entity.y && this.board ? this.board.getCell(entity.x, entity.y) : undefined;\n      entity.tick(this.frame, cell, this.board.player, this.board.ghosts);\n    });\n    //Handle Render\n    this.entList.forEach((entity) => {\n      if (!entity.draw || !this.canvas) { return }\n      var cell = entity.x && entity.y && this.board ? this.board.getCell(entity.x, entity.y) : undefined;\n      (!entity._renderData.ready && entity.prepDraw) ? entity.prepDraw(this.canvas) : undefined;\n      entity.draw(this.canvas, this.frame, cell, this.board.player, this.board.ghosts);\n    });\n    this.frame++;\n  }\n  startTick() {\n    if (!this.ticking) {\n      this.intervalDigit = setInterval(this.tick.bind(this), this.tickInterval);\n      this.ticking = true;\n    }\n  }\n  stopTick() {\n    if (this.ticking) {\n      clearInterval(this.intervalDigit);\n      this.ticking = false;\n    }\n  }\n}\n\nmodule.exports = new Ticker();\n\n//# sourceURL=webpack://pacman/./src/bin/world/ticker.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const Board = __webpack_require__(/*! ./bin/world/board */ \"./src/bin/world/board.js\");\nconst Ticker = __webpack_require__(/*! ./bin/world/ticker */ \"./src/bin/world/ticker.js\"); window.ticker = Ticker; //For Dev Purposes\nconst oCanvas = __webpack_require__(/*! ocanvas */ \"./node_modules/ocanvas/index.js\");\n\nwindow.defaultTileSize = 26;\ndocument.getElementById('pacmanGame').setAttribute('width', window.defaultTileSize * 28);\ndocument.getElementById('pacmanGame').setAttribute('height', window.defaultTileSize * 31);\n\n\n//prepare canvas to render to\nconst canvas = oCanvas.create({\n  canvas: \"#pacmanGame\",\n  background: \"#000\",\n  fps: 60\n});\n\nTicker.setCanvas(canvas);\nvar board = new Board();\nwindow.ticker.register(board);\n\n//# sourceURL=webpack://pacman/./src/entry.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;